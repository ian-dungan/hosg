<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Heroes of Shady Grove v2.0.0</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #141826 0, #05060b 50%, #000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }

    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
      gap: 12px;
    }

    #hud-left, #hud-right {
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: auto;
    }

    .hud-panel {
      background: rgba(5, 5, 15, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(130, 180, 255, 0.4);
      padding: 8px 10px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(6px);
      min-width: 180px;
    }

    .hud-title {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 4px;
      color: #9bc3ff;
    }

    .bar {
      position: relative;
      width: 100%;
      height: 14px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.08);
      margin-bottom: 4px;
    }

    .bar-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 60%;
      border-radius: inherit;
      transition: width 0.15s linear;
    }

    #hp-fill {
      background: linear-gradient(90deg, #f74b4b, #ffb347);
      box-shadow: 0 0 10px rgba(247, 75, 75, 0.6);
    }

    #mp-fill {
      background: linear-gradient(90deg, #5b8dff, #b77bff);
      box-shadow: 0 0 10px rgba(91, 141, 255, 0.6);
    }

    .bar-label {
      font-size: 11px;
      opacity: 0.9;
      display: flex;
      justify-content: space-between;
      margin-top: 1px;
    }

    #xp-row {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 11px;
      margin-top: 2px;
      opacity: 0.9;
    }

    #xp-bar {
      flex: 1;
      height: 6px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.12);
      position: relative;
    }

    #xp-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 25%;
      border-radius: inherit;
      background: linear-gradient(90deg, #ffe164, #ff9f43);
      box-shadow: 0 0 6px rgba(255, 225, 100, 0.7);
    }

    #minimap {
      width: 180px;
      height: 180px;
      border-radius: 999px;
      border: 2px solid rgba(130, 180, 255, 0.8);
      background: radial-gradient(circle at 30% 30%, #3b5b4a, #12201b 55%, #050809 100%);
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 16px rgba(0, 0, 0, 0.7);
    }

    #minimap-center {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #ffe164;
      border: 1px solid #000;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px rgba(255, 225, 100, 0.8);
    }

    #minimap-border {
      position: absolute;
      inset: 6px;
      border-radius: inherit;
      border: 1px solid rgba(255, 255, 255, 0.35);
      pointer-events: none;
    }

    #target-frame {
      display: none;
      background: rgba(5, 5, 15, 0.95);
      border-radius: 10px;
      border: 1px solid rgba(255, 80, 80, 0.6);
      padding: 8px 10px;
      box-shadow: 0 0 15px rgba(255, 80, 80, 0.4);
      backdrop-filter: blur(6px);
      min-width: 180px;
    }

    #target-name {
      font-size: 13px;
      color: #ff8080;
      margin-bottom: 4px;
      font-weight: 600;
    }

    #hotbar {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      z-index: 20;
      pointer-events: auto;
    }

    .hotbar-slot {
      width: 50px;
      height: 50px;
      background: rgba(10, 10, 30, 0.9);
      border: 2px solid #4a9eff;
      border-radius: 8px;
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
    }

    .hotbar-slot:hover {
      transform: scale(1.1);
      border-color: #ffd700;
    }

    .hotbar-slot:active {
      transform: scale(0.95);
    }

    .hotbar-slot .skill-icon {
      font-size: 24px;
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hotbar-slot .keybind {
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 10px;
      color: #aaa;
      background: rgba(0,0,0,0.5);
      padding: 1px 3px;
      border-radius: 2px;
    }

    
#char-create-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, rgba(15, 20, 45, 0.96), rgba(3, 3, 8, 0.98));
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 20;
}

#char-create-card {
  width: 360px;
  max-width: 92%;
  background: rgba(4, 6, 18, 0.96);
  border-radius: 18px;
  padding: 18px 20px 16px;
  border: 1px solid rgba(130, 180, 255, 0.65);
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
}

#char-title {
  font-size: 20px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 4px;
  color: #ffe164;
  text-shadow: 0 0 10px rgba(255, 225, 100, 0.8);
}

#char-subtitle {
  font-size: 12px;
  text-align: center;
  margin-bottom: 12px;
  color: #cfd8ff;
}

.char-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
  font-size: 12px;
}

.char-field span {
  color: #9db8ff;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  font-size: 11px;
}

.char-field input,
.char-field select {
  padding: 6px 8px;
  border-radius: 8px;
  border: 1px solid rgba(130, 180, 255, 0.6);
  background: rgba(5, 8, 20, 0.96);
  color: #f5f5f5;
  font-size: 12px;
  outline: none;
}

#char-colors {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px;
  margin-bottom: 12px;
  font-size: 11px;
}

#char-colors label {
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: stretch;
}

#char-colors span {
  color: #9db8ff;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  font-size: 10px;
}

#char-colors input[type="color"] {
  width: 100%;
  height: 26px;
  padding: 0;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.7);
  background: transparent;
  cursor: pointer;
}

#char-buttons {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

#char-buttons button {
  flex: 1;
  padding: 7px 10px;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.8);
  background: radial-gradient(circle at 30% 0%, #4a7bff, #7a4aff);
  color: #fff;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.9);
}

#char-buttons button:hover {
  filter: brightness(1.1);
}

#char-note {
  font-size: 10px;
  color: #9da8d6;
  text-align: center;
}

#char-slot-wrapper {
  margin-top: 8px;
  margin-bottom: 10px;
  padding: 8px 10px;
  border-radius: 10px;
  background: rgba(8, 15, 40, 0.9);
  border: 1px solid rgba(130, 180, 255, 0.45);
  max-height: 180px;
  overflow-y: auto;
}

#char-slot-header {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #9db8ff;
  margin-bottom: 6px;
}

#char-slot-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.char-slot-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 6px;
  border-radius: 6px;
  background: rgba(12, 20, 52, 0.95);
  border: 1px solid rgba(60, 110, 200, 0.6);
}

.char-slot-main {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.char-slot-name {
  font-size: 12px;
  font-weight: 600;
  color: #e2e8ff;
}

.char-slot-meta {
  font-size: 10px;
  color: #9da8d6;
}

.char-slot-actions {
  display: flex;
  gap: 4px;
}

.char-slot-actions button {
  font-size: 10px;
  padding: 3px 6px;
  border-radius: 6px;
  border: 1px solid rgba(130, 180, 255, 0.7);
  background: linear-gradient(to bottom, #3047a0, #192044);
  color: #f8f9ff;
  cursor: pointer;
}

.char-slot-actions button:hover {
  filter: brightness(1.08);
}

.char-slot-empty {
  font-size: 11px;
  color: #9da8d6;
}

#char-slot-warning {
  margin-top: 4px;
  font-size: 10px;
  color: #ffdd89;
  text-align: right;
}

#account-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, rgba(15, 20, 45, 0.96), rgba(3, 3, 8, 0.98));
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 30;
}

#account-card {
  width: 320px;
  max-width: 92%;
  background: rgba(4, 6, 18, 0.96);
  border-radius: 18px;
  padding: 18px 20px 16px;
  border: 1px solid rgba(130, 180, 255, 0.65);
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
}

#acct-title {
  font-size: 20px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 4px;
  color: #ffe164;
  text-shadow: 0 0 10px rgba(255, 225, 100, 0.8);
}

#acct-subtitle {
  font-size: 12px;
  text-align: center;
  margin-bottom: 12px;
  color: #cfd8ff;
}

.acct-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 8px;
}

.acct-field span {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #9db8ff;
}

.acct-field input {
  height: 28px;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.8);
  padding: 0 10px;
  background: rgba(9, 13, 32, 0.95);
  color: #e2e8ff;
}

#acct-buttons {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

#acct-buttons button {
  flex: 1;
  height: 30px;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.9);
  background: linear-gradient(to bottom, #3c5ad8, #101632);
  color: #fdfbff;
  font-weight: 600;
  font-size: 12px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  cursor: pointer;
}

#acct-buttons button:hover {
  filter: brightness(1.08);
}

#acct-message {
  min-height: 16px;
  font-size: 11px;
  color: #ffb4b4;
  text-align: center;
}


    #chat-panel {
      position: fixed;
      left: 12px;
      bottom: 12px;
      width: 320px;
      max-width: calc(100% - 24px);
      background: rgba(0, 0, 0, 0.78);
      border-radius: 10px;
      border: 1px solid rgba(130, 180, 255, 0.4);
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.75);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 10;
      pointer-events: auto;
    }

    #chat-log {
      padding: 6px 8px;
      height: 120px;
      font-size: 11px;
      overflow-y: auto;
      color: #d8e4ff;
      background: rgba(5, 8, 18, 0.9);
    }

    #chat-input-row {
      display: flex;
      border-top: 1px solid rgba(130, 180, 255, 0.5);
      background: rgba(10, 14, 26, 0.96);
    }

    #chat-input {
      flex: 1;
      padding: 6px 8px;
      border: none;
      outline: none;
      background: transparent;
      color: #f5f5f5;
      font-size: 11px;
    }

    #chat-input::placeholder {
      color: rgba(200, 215, 240, 0.7);
    }

    #chat-send {
      padding: 0 10px;
      border: none;
      background: linear-gradient(135deg, #4a7bff, #7a4aff);
      color: #fff;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      border-radius: 0;
    }

    #chat-send:hover {
      filter: brightness(1.1);
    }

        #mp-status {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 11;
      background: rgba(5, 5, 15, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(130, 180, 255, 0.6);
      padding: 4px 10px;
      font-size: 11px;
      color: #cfd8ff;
      pointer-events: auto;
    }

    #mp-status-text.online {
      color: #6bff7b;
    }

    #mp-status-text.offline {
      color: #ff7070;
    }

    #helper-keys {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 10;
      background: rgba(5, 5, 15, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(130, 180, 255, 0.4);
      padding: 6px 10px;
      font-size: 11px;
      color: #cfd8ff;
      pointer-events: auto;
      max-width: 260px;
    }

    #helper-keys strong {
      color: #ffe164;
    }

    #mobile-controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 12px;
      display: none;
      justify-content: space-between;
      align-items: flex-end;
      z-index: 15;
      pointer-events: none;
    }

    #joystick-base {
      width: 140px;
      height: 140px;
      border-radius: 999px;
      border: 2px solid rgba(130, 180, 255, 0.8);
      background: radial-gradient(circle at 30% 30%, rgba(120, 200, 255, 0.25), rgba(5, 10, 20, 0.9));
      box-shadow: 0 0 16px rgba(0, 0, 0, 0.7);
      position: relative;
      pointer-events: auto;
      touch-action: none;
    }

    #joystick-thumb {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 56px;
      height: 56px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #ffe164, #c28b2b);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(255, 225, 100, 0.8);
    }

    #mobile-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
    }

    #mobile-buttons button {
      min-width: 86px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(130, 180, 255, 0.7);
      background: radial-gradient(circle at 30% 0%, #4a7bff, #7a4aff);
      color: #fff;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      box-shadow: 0 0 14px rgba(0, 0, 0, 0.8);
      cursor: pointer;
    }

    #mobile-buttons button:active {
      transform: scale(0.97);
      filter: brightness(1.1);
    }

    @media (max-width: 768px) {
    #chat-panel {
        width: calc(100% - 24px);
      }
    #helper-keys {
        display: none;
      }
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="hosg_config.js"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  <script src="hosg_asset_loader.js"></script>
  <script src="hosg_game_systems.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="hud">
    <div id="hud-left">
      <div class="hud-panel">
        <div class="hud-title"><span id="hud-hero-name">Felix of Shady Grove</span></div>
        <div class="bar">
          <div id="hp-fill" class="bar-fill"></div>
        </div>
        <div class="bar-label">
          <span>HP</span>
          <span id="hp-label">100 / 100</span>
        </div>
        <div class="bar">
          <div id="mp-fill" class="bar-fill"></div>
        </div>
        <div class="bar-label">
          <span>MP</span>
          <span id="mp-label">60 / 100</span>
        </div>
        <div id="xp-row">
          <span>Lv. <span id="level-label">1</span></span>
          <div id="xp-bar"><div id="xp-fill"></div></div>
          <span id="xp-label">25%</span>
        </div>
      </div>

      <div id="target-frame" class="hud-panel">
        <div id="target-name">No Target</div>
        <div class="bar">
          <div id="target-hp-fill" class="bar-fill" style="background: linear-gradient(90deg, #ff4040, #ff8080);"></div>
        </div>
        <div class="bar-label">
          <span>HP</span>
          <span id="target-hp-label">0 / 0</span>
        </div>
      </div>
    </div>
    <div id="hud-right">
      <div id="minimap" class="hud-panel">
        <div id="minimap-center"></div>
        <div id="minimap-border"></div>
      </div>
    </div>
  </div>

<div id="account-overlay">
  <div id="account-card">
    <div id="acct-title">Heroes of Shady Grove</div>
    <div id="acct-subtitle">Sign in or create an account</div>
    <label class="acct-field">
      <span>Email</span>
      <input id="acct-email" type="email" autocomplete="email" />
    </label>
    <label class="acct-field">
      <span>Password</span>
      <input id="acct-password" type="password" autocomplete="current-password" />
    </label>
    <div id="acct-buttons">
      <button id="acct-signin" type="button">Sign in</button>
      <button id="acct-signup" type="button">Create account</button>
    </div>
    <div id="acct-message"></div>
  </div>
</div>

<div id="char-create-overlay">
  <div id="char-create-card">
    <div id="char-title">Heroes of Shady Grove</div>
    <div id="char-subtitle">Create your hero</div>
    <div id="char-slot-wrapper">
      <div id="char-slot-header">Your heroes</div>
      <div id="char-slot-list"></div>
      <div id="char-slot-warning"></div>
    </div>
    <label class="char-field">
      <span>Name</span>
      <input id="cc-name" type="text" maxlength="16" placeholder="Felix" />
    </label>
    <label class="char-field">
      <span>Role</span>
      <select id="cc-role">
        <option value="Adventurer">Adventurer</option>
        <option value="Knight">Knight</option>
        <option value="Ranger">Ranger</option>
        <option value="Mage">Mage</option>
      </select>
    </label>
    <div id="char-colors">
      <label>
        <span>Tunic</span>
        <input id="cc-tunic" type="color" value="#344fba" />
      </label>
      <label>
        <span>Pants</span>
        <input id="cc-pants" type="color" value="#1f2937" />
      </label>
      <label>
        <span>Skin</span>
        <input id="cc-skin" type="color" value="#f3dec0" />
      </label>
    </div>
    <div id="char-buttons">
      <button id="cc-random">Randomize</button>
      <button id="cc-start">Enter the world</button>
    </div>
    <div id="char-note">Heroes are saved automatically; if an online account is configured, they also sync to the server.</div>
  </div>
</div>

  <div id="hotbar">
    <div class="hotbar-slot" data-key="1" onclick="window.useHotbarSkill(1)">
      <div class="skill-icon">‚öîÔ∏è</div>
      <div class="keybind">1</div>
    </div>
    <div class="hotbar-slot" data-key="2" onclick="window.useHotbarSkill(2)">
      <div class="skill-icon">üî•</div>
      <div class="keybind">2</div>
    </div>
    <div class="hotbar-slot" data-key="3" onclick="window.useHotbarSkill(3)">
      <div class="skill-icon">‚ùÑÔ∏è</div>
      <div class="keybind">3</div>
    </div>
    <div class="hotbar-slot" data-key="4" onclick="window.useHotbarSkill(4)">
      <div class="skill-icon">‚ö°</div>
      <div class="keybind">4</div>
    </div>
  </div>

  <div id="chat-panel">
    <div id="chat-log"></div>
    <div id="chat-input-row">
      <input id="chat-input" placeholder="Type to chat..." />
      <button id="chat-send">Send</button>
    </div>
  </div>

  <div id="mp-status">MP: <span id="mp-status-text">Offline</span></div>

  <div id="helper-keys">
    <div><strong>Controls</strong></div>
    <div>W / A / S / D ‚Äì Move</div>
    <div>Right mouse drag ‚Äì Orbit camera</div>
    <div>Shift / B ‚Äì Run</div>
    <div>Space / A ‚Äì Jump</div>
    <div>Tab ‚Äì Target enemy</div>
    <div>1-4 ‚Äì Use skills</div>
    <div>Scroll ‚Äì Zoom camera</div>
  </div>

  <div id="mobile-controls">
    <div id="joystick-base">
      <div id="joystick-thumb"></div>
    </div>
    <div id="mobile-buttons">
      <button id="btn-jump">Jump</button>
      <button id="btn-run">Run</button>
    </div>
  </div>

  <script>

const HOSG_SAVE_KEY = "hosg_player_v1";
let playerState = null;

const HOSG_MAX_CHARACTERS = 10;

// Supabase config is in hosg_config.js (HOSG_CONFIG object)
const HOSG_SUPABASE_URL = typeof HOSG_CONFIG !== "undefined" ? HOSG_CONFIG.supabase.url : "";
const HOSG_SUPABASE_ANON_KEY = typeof HOSG_CONFIG !== "undefined" ? HOSG_CONFIG.supabase.anonKey : "";

const HOSG_ACCOUNTS_TABLE = "hosg_accounts";
const HOSG_ACCOUNT_ID_COLUMN = "id";
const HOSG_ACCOUNT_EMAIL_COLUMN = "email";
const HOSG_ACCOUNT_USERNAME_COLUMN = "username";
const HOSG_ACCOUNT_PASSWORD_HASH_COLUMN = "password_hash";

const HOSG_CHARACTERS_TABLE = "hosg_characters";
const HOSG_CHARACTER_ID_COLUMN = "id";
const HOSG_CHARACTER_ACCOUNT_ID_COLUMN = "account_id";

// hosgSupabase is declared in hosg_config.js
let hosgAccount = null;
let hosgCharacters = [];
let hosgCurrentCharacterId = null;
let hosgSupabaseSaveTimer = null;

function hosgHasSupabaseConfig() {
  try {
    return typeof HOSG_CONFIG !== "undefined" &&
      HOSG_CONFIG.supabase.url !== 'YOUR_SUPABASE_URL_HERE' &&
      !!HOSG_CONFIG.supabase.url &&
      !!HOSG_CONFIG.supabase.anonKey;
  } catch (e) {
    return false;
  }
}

async function hosgEnsureSupabase() {
  if (!hosgHasSupabaseConfig()) return null;
  if (hosgSupabase) return hosgSupabase;
  // hosgSupabase is already initialized in hosg_config.js
  return hosgSupabase;
}

async function hosgHashPassword(plain) {
  try {
    if (window.crypto && window.crypto.subtle && window.TextEncoder) {
      const enc = new TextEncoder().encode(plain);
      const buf = await window.crypto.subtle.digest("SHA-256", enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2, "0")).join("");
    }
  } catch (e) {
    console.warn("[HOSG] Web Crypto unavailable, using fallback hash", e);
  }
  let h = 0;
  for (let i = 0; i < plain.length; i++) {
    h = (h * 31 + plain.charCodeAt(i)) >>> 0;
  }
  return h.toString(16);
}

async function hosgAuthWithEmailPassword(mode, email, password) {
  const sb = await hosgEnsureSupabase();
  if (!sb) {
    throw new Error("Online accounts are not available on this build.");
  }

  const trimmedEmail = (email || "").trim().toLowerCase();
  const trimmedPass = (password || "").trim();

  if (!trimmedEmail || !trimmedPass) {
    throw new Error("Please enter both email and password.");
  }

  const passwordHash = await hosgHashPassword(trimmedPass);

  if (mode === "signup") {
    const { data: existing, error: existingError } = await sb
      .from(HOSG_ACCOUNTS_TABLE)
      .select(HOSG_ACCOUNT_ID_COLUMN)
      .eq(HOSG_ACCOUNT_EMAIL_COLUMN, trimmedEmail)
      .limit(1);

    if (existingError) {
      console.warn("[HOSG] Account lookup failed", existingError);
      throw new Error("Could not check existing accounts.");
    }
    if (existing && existing.length > 0) {
      throw new Error("An account with that email already exists.");
    }

    let username = trimmedEmail.split("@")[0] || trimmedEmail;
    username = username.slice(0, 24);

    const payload = {};
    payload[HOSG_ACCOUNT_EMAIL_COLUMN] = trimmedEmail;
    payload[HOSG_ACCOUNT_USERNAME_COLUMN] = username;
    payload[HOSG_ACCOUNT_PASSWORD_HASH_COLUMN] = passwordHash;

    const { data, error } = await sb
      .from(HOSG_ACCOUNTS_TABLE)
      .insert(payload)
      .select()
      .single();

    if (error) {
      console.warn("[HOSG] Account creation failed", error);
      throw new Error("Could not create account. Please try again.");
    }

    hosgAccount = data;
    try {
      await sb
        .from(HOSG_ACCOUNTS_TABLE)
        .update({ last_login_at: new Date().toISOString() })
        .eq(HOSG_ACCOUNT_ID_COLUMN, hosgAccount[HOSG_ACCOUNT_ID_COLUMN]);
    } catch (e) {
      console.warn("[HOSG] Failed to update last_login_at on signup", e);
    }
    return hosgAccount;
  } else {
    const { data, error } = await sb
      .from(HOSG_ACCOUNTS_TABLE)
      .select("*")
      .eq(HOSG_ACCOUNT_EMAIL_COLUMN, trimmedEmail)
      .limit(1);

    if (error) {
      console.warn("[HOSG] Account lookup failed", error);
      throw new Error("Could not look up account.");
    }

    if (!data || data.length === 0) {
      throw new Error("Account not found.");
    }

    const account = data[0];
    const storedHash = account[HOSG_ACCOUNT_PASSWORD_HASH_COLUMN];
    if (!storedHash || storedHash !== passwordHash) {
      throw new Error("Incorrect password.");
    }

    hosgAccount = account;
    try {
      await sb
        .from(HOSG_ACCOUNTS_TABLE)
        .update({ last_login_at: new Date().toISOString() })
        .eq(HOSG_ACCOUNT_ID_COLUMN, hosgAccount[HOSG_ACCOUNT_ID_COLUMN]);
    } catch (e) {
      console.warn("[HOSG] Failed to update last_login_at on signin", e);
    }
    return hosgAccount;
  }
}

function hosgBuildCharacterUpdatePayloadFromState(state) {
  const s = state && state.stats ? state.stats : {};
  const pos = state && state.position ? state.position : {};
  const levelVal = (typeof s.level === "number") ? s.level : 1;
  const xpVal = (s.xp != null) ? s.xp : 0;
  const currentZoneId = (state && state.currentZoneId != null) ? state.currentZoneId : null;

  return {
    name: state && state.name ? state.name : "Unnamed hero",
    level: levelVal,
    xp: xpVal,
    appearance: state && state.appearance ? state.appearance : null,
    stats: s,
    position_x: pos.x != null ? pos.x : 0,
    position_y: pos.y != null ? pos.y : 0,
    position_z: pos.z != null ? pos.z : 0,
    rotation_y: typeof state.rotationY === "number" ? state.rotationY : 0,
    current_zone_id: currentZoneId,
    is_deleted: false
  };
}

function hosgBuildCharacterInsertPayloadFromState(state, accountId, slotIndex) {
  const base = hosgBuildCharacterUpdatePayloadFromState(state);
  base[HOSG_CHARACTER_ACCOUNT_ID_COLUMN] = accountId;
  base.slot_index = slotIndex;
  base.created_at = new Date().toISOString();
  base.updated_at = base.created_at;
  return base;
}

async function hosgCreateCharacterFromState(state) {
  const sb = await hosgEnsureSupabase();
  if (!sb || !hosgAccount) return null;

  const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];

  const rawName = state && state.name ? String(state.name) : "";
  const trimmedName = rawName.trim();
  if (trimmedName) {
    const { data: existingByName, error: nameLookupError } = await sb
      .from(HOSG_CHARACTERS_TABLE)
      .select(HOSG_CHARACTER_ID_COLUMN)
      .ilike("name", trimmedName)
      .eq("is_deleted", false)
      .limit(1);

    if (nameLookupError) {
      console.warn("[HOSG] Character name lookup failed", nameLookupError);
      throw new Error("Could not check hero names. Please try again.");
    }
    if (existingByName && existingByName.length > 0) {
      throw new Error("A hero with that name already exists.");
    }
  }

  const usedSlots = (hosgCharacters || [])
    .filter(c => !c.is_deleted)
    .map(c => c.slot_index)
    .filter(v => typeof v === "number");

  let slotIndex = 0;
  while (usedSlots.includes(slotIndex) && slotIndex < HOSG_MAX_CHARACTERS) {
    slotIndex++;
  }
  if (slotIndex >= HOSG_MAX_CHARACTERS) {
    throw new Error("You have reached the maximum number of heroes on this account.");
  }

  const payload = hosgBuildCharacterInsertPayloadFromState(state, accountIdVal, slotIndex);

  const { data, error } = await sb
    .from(HOSG_CHARACTERS_TABLE)
    .insert(payload)
    .select()
    .single();

  if (error) {
    console.warn("[HOSG] Failed to create character", error);
    throw new Error("Could not create hero on the server.");
  }

  return data;
}

async function hosgUpdateCharacterFromState(id, state) {
  if (!id) return;
  const sb = await hosgEnsureSupabase();
  if (!sb || !hosgAccount) return;

  const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];

  const rawName = state && state.name ? String(state.name) : "";
  const trimmedName = rawName.trim();
  if (trimmedName) {
    const { data: existingByName, error: nameLookupError } = await sb
      .from(HOSG_CHARACTERS_TABLE)
      .select(HOSG_CHARACTER_ID_COLUMN)
      .ilike("name", trimmedName)
      .eq("is_deleted", false)
      .neq(HOSG_CHARACTER_ID_COLUMN, id)
      .limit(1);

    if (nameLookupError) {
      console.warn("[HOSG] Character name lookup failed (update)", nameLookupError);
      throw new Error("Could not check hero names. Please try again.");
    }
    if (existingByName && existingByName.length > 0) {
      throw new Error("A hero with that name already exists.");
    }
  }

  const payload = hosgBuildCharacterUpdatePayloadFromState(state);
  payload.updated_at = new Date().toISOString();

  const { error } = await sb
    .from(HOSG_CHARACTERS_TABLE)
    .update(payload)
    .eq(HOSG_CHARACTER_ID_COLUMN, id)
    .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal)
    .eq("is_deleted", false);

  if (error) {
    console.warn("[HOSG] Failed to update character", error);
  }
}

async function hosgLoadCharacters() {
  const sb = await hosgEnsureSupabase();
  if (!sb || !hosgAccount) {
    hosgCharacters = [];
    return [];
  }

  const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];

  const { data, error } = await sb
    .from(HOSG_CHARACTERS_TABLE)
    .select("*")
    .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal)
    .eq("is_deleted", false)
    .order("slot_index", { ascending: true });

  if (error) {
    console.warn("[HOSG] Failed to load characters", error);
    hosgCharacters = [];
    return [];
  }

  hosgCharacters = data || [];
  try {
    hosgRefreshCharacterListUI();
  } catch (e) {
    console.warn("[HOSG] Failed to refresh character list UI", e);
  }
  return hosgCharacters;
}

function hosgBuildPlayerStateFromCharacter(row) {
  const base = getDefaultPlayerState();
  const out = Object.assign({}, base);

  if (row && row.name) out.name = row.name;
  if (row && row.stats && typeof row.stats === "object") {
    out.stats = Object.assign({}, base.stats, row.stats);
  } else if (row) {
    const s = Object.assign({}, base.stats);
    if (typeof row.level === "number") s.level = row.level;
    if (row.xp != null) s.xp = Number(row.xp);
    out.stats = s;
  }

  if (row && row.appearance && typeof row.appearance === "object") {
    out.appearance = Object.assign({}, base.appearance, row.appearance);
  }

  out.position = {
    x: row && row.position_x != null ? Number(row.position_x) : base.position.x,
    y: row && row.position_y != null ? Number(row.position_y) : base.position.y,
    z: row && row.position_z != null ? Number(row.position_z) : base.position.z
  };
  out.rotationY = row && row.rotation_y != null ? Number(row.rotation_y) : base.rotationY || 0;

  return out;
}

function hosgScheduleSupabaseCharacterSave() {
  if (!hosgHasSupabaseConfig() || !hosgAccount || !hosgCurrentCharacterId || !playerState) {
    return;
  }
  if (hosgSupabaseSaveTimer) return;

  hosgSupabaseSaveTimer = setTimeout(async function () {
    hosgSupabaseSaveTimer = null;
    try {
      await hosgUpdateCharacterFromState(hosgCurrentCharacterId, playerState);
    } catch (e) {
      console.warn("[HOSG] Failed to save character to Supabase", e);
    }
  }, 1000);
}

function hosgRefreshCharacterListUI() {
  const listEl = document.getElementById("char-slot-list");
  const warningEl = document.getElementById("char-slot-warning");
  if (!listEl || !warningEl) return;

  listEl.innerHTML = "";

  if (!hosgCharacters || hosgCharacters.length === 0) {
    const empty = document.createElement("div");
    empty.className = "char-slot-empty";
    empty.textContent = "No heroes yet. Create one below.";
    listEl.appendChild(empty);
  } else {
    hosgCharacters.forEach(function (c) {
      if (c.is_deleted) return;

      const row = document.createElement("div");
      row.className = "char-slot-row";

      const main = document.createElement("div");
      main.className = "char-slot-main";

      const nameEl = document.createElement("div");
      nameEl.className = "char-slot-name";
      nameEl.textContent = c.name || "Unnamed hero";

      const metaEl = document.createElement("div");
      metaEl.className = "char-slot-meta";
      const levelVal = (typeof c.level === "number") ? c.level :
        (c.stats && typeof c.stats.level === "number") ? c.stats.level : 1;
      metaEl.textContent = "Level " + levelVal + (c.current_zone_id ? " ‚Ä¢ Zone " + c.current_zone_id : "");

      main.appendChild(nameEl);
      main.appendChild(metaEl);

      const actions = document.createElement("div");
      actions.className = "char-slot-actions";

      const loadBtn = document.createElement("button");
      loadBtn.textContent = "Load";
      loadBtn.addEventListener("click", function () {
        try {
          hosgCurrentCharacterId = c[HOSG_CHARACTER_ID_COLUMN];
          playerState = hosgBuildPlayerStateFromCharacter(c);
          window.localStorage.setItem(HOSG_SAVE_KEY, JSON.stringify(playerState));
          if (typeof window.applyStateToCharacterForm === "function") {
            window.applyStateToCharacterForm();
          }
        } catch (e) {
          console.warn("[HOSG] Failed to load hero from slot", e);
        }
      });

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener("click", async function () {
        const ok = window.confirm("Delete this hero permanently? This cannot be undone.");
        if (!ok) return;
        try {
          const sb = await hosgEnsureSupabase();
          if (!sb || !hosgAccount) return;

          const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];
          const payload = {
            is_deleted: true,
            deleted_at: new Date().toISOString(),
            delete_reason: "Deleted from client"
          };

          const { error } = await sb
            .from(HOSG_CHARACTERS_TABLE)
            .update(payload)
            .eq(HOSG_CHARACTER_ID_COLUMN, c[HOSG_CHARACTER_ID_COLUMN])
            .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal);

          if (error) {
            console.warn("[HOSG] Failed to soft-delete character", error);
            return;
          }

          hosgCharacters = hosgCharacters.filter(function (ch) {
            return ch[HOSG_CHARACTER_ID_COLUMN] !== c[HOSG_CHARACTER_ID_COLUMN];
          });
          if (hosgCurrentCharacterId === c[HOSG_CHARACTER_ID_COLUMN]) {
            hosgCurrentCharacterId = null;
          }
          hosgRefreshCharacterListUI();
        } catch (e) {
          console.warn("[HOSG] Delete hero error", e);
        }
      });

      actions.appendChild(loadBtn);
      actions.appendChild(deleteBtn);

      row.appendChild(main);
      row.appendChild(actions);

      listEl.appendChild(row);
    });
  }

  const activeCount = (hosgCharacters || []).filter(function (c) {
    return !c.is_deleted;
  }).length;

  warningEl.textContent = "Heroes on this account: " + activeCount + " / " + HOSG_MAX_CHARACTERS;
  if (activeCount >= HOSG_MAX_CHARACTERS) {
    warningEl.textContent += " (maximum reached; delete one to create a new hero)";
  }
}

let hp = 100, maxHp = 100;
let mp = 60, maxMp = 100;
let xp = 25, level = 1;

function getDefaultPlayerState() {
  return {
    name: "Felix",
    role: "Adventurer",
    appearance: {
      tunic: "#344fba",
      pants: "#1f2937",
      skin: "#f3dec0",
      boots: "#3b2313"
    },
    stats: {
      hp: 100,
      maxHp: 100,
      mp: 60,
      maxMp: 100,
      xp: 25,
      level: 1
    },
    position: { x: 0, y: 1.5, z: 0 },
    rotationY: 0
  };
}

function loadPlayerState() {
  try {
    const raw = window.localStorage.getItem(HOSG_SAVE_KEY);
    if (!raw) {
      playerState = getDefaultPlayerState();
      return;
    }
    const parsed = JSON.parse(raw);
    playerState = Object.assign(getDefaultPlayerState(), parsed);
    if (!playerState.appearance) playerState.appearance = getDefaultPlayerState().appearance;
    if (!playerState.stats) playerState.stats = getDefaultPlayerState().stats;
    if (!playerState.position) playerState.position = getDefaultPlayerState().position;
    if (typeof playerState.rotationY !== "number") playerState.rotationY = 0;
  } catch (e) {
    console.warn("Failed to load player state, using defaults", e);
    playerState = getDefaultPlayerState();
  }
}

function savePlayerStateRuntime(heroBody, hp, maxHp, mp, maxMp, xp, level) {
  if (!playerState) return;
  try {
    playerState.stats = { hp, maxHp, mp, maxMp, xp, level };
    if (heroBody && heroBody.position) {
      playerState.position = {
        x: heroBody.position.x,
        y: heroBody.position.y,
        z: heroBody.position.z
      };
      playerState.rotationY = heroBody.rotation.y;
    }
    window.localStorage.setItem(HOSG_SAVE_KEY, JSON.stringify(playerState));
    hosgScheduleSupabaseCharacterSave();
  } catch (e) {
    console.warn("Failed to save player state", e);
  }
}

function applyAppearanceToMaterials(scene, mats) {
  if (!playerState || !playerState.appearance) return;
  const a = playerState.appearance;
  function hexToColor3(hex) {
    if (!hex || typeof hex !== "string") return new BABYLON.Color3(1, 1, 1);
    const h = hex.replace("#", "");
    if (h.length !== 6) return new BABYLON.Color3(1, 1, 1);
    const r = parseInt(h.substring(0, 2), 16) / 255;
    const g = parseInt(h.substring(2, 4), 16) / 255;
    const b = parseInt(h.substring(4, 6), 16) / 255;
    return new BABYLON.Color3(r, g, b);
  }
  if (mats.skin) mats.skin.diffuseColor = hexToColor3(a.skin);
  if (mats.tunic) mats.tunic.diffuseColor = hexToColor3(a.tunic);
  if (mats.pants) mats.pants.diffuseColor = hexToColor3(a.pants);
  if (mats.boots) mats.boots.diffuseColor = hexToColor3(a.boots);
}

function setupCharacterCreationUI() {
  const overlay = document.getElementById("char-create-overlay");
  if (!overlay) return;

  const nameInput = document.getElementById("cc-name");
  const roleSelect = document.getElementById("cc-role");
  const tunicInput = document.getElementById("cc-tunic");
  const pantsInput = document.getElementById("cc-pants");
  const skinInput = document.getElementById("cc-skin");
  const randomBtn = document.getElementById("cc-random");
  const startBtn = document.getElementById("cc-start");
  const hudName = document.getElementById("hud-hero-name");

  if (!playerState) loadPlayerState();

  function applyStateToForm() {
    if (!playerState) return;
    nameInput.value = playerState.name || "Felix";
    roleSelect.value = playerState.role || "Adventurer";
    const ap = playerState.appearance || {};
    tunicInput.value = ap.tunic || "#344fba";
    pantsInput.value = ap.pants || "#1f2937";
    skinInput.value = ap.skin || "#f3dec0";
  }

  applyStateToForm();
  window.applyStateToCharacterForm = applyStateToForm;

  function randomColor() {
    const h = Math.floor(Math.random() * 360);
    const s = 40 + Math.random() * 40;
    const l = 40 + Math.random() * 10;
    const c = (1 - Math.abs(2 * l / 100 - 1)) * (s / 100);
    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    const m = l / 100 - c / 2;
    let r = 0, g = 0, b = 0;
    if (h < 60) { r = c; g = x; b = 0; }
    else if (h < 120) { r = x; g = c; b = 0; }
    else if (h < 180) { r = 0; g = c; b = x; }
    else if (h < 240) { r = 0; g = x; b = c; }
    else if (h < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return "#" + r.toString(16).padStart(2, "0") +
                 g.toString(16).padStart(2, "0") +
                 b.toString(16).padStart(2, "0");
  }

  randomBtn.addEventListener("click", function () {
    tunicInput.value = randomColor();
    pantsInput.value = randomColor();
  });

  function applyFromUI() {
    const name = (nameInput.value || "Felix").trim();
    const role = roleSelect.value || "Adventurer";
    const tunic = tunicInput.value || "#344fba";
    const pants = pantsInput.value || "#1f2937";
    const skin = skinInput.value || "#f3dec0";

    playerState.name = name;
    playerState.role = role;
    playerState.appearance = Object.assign({}, playerState.appearance || {}, {
      tunic, pants, skin
    });

    if (hudName) {
      hudName.textContent = name + " of Shady Grove";
    }
  }

  startBtn.addEventListener("click", async function () {
    applyFromUI();

    if (hosgHasSupabaseConfig() && hosgAccount && playerState) {
      try {
        const sb = await hosgEnsureSupabase();
        if (!sb) {
          throw new Error("Online accounts are not available on this build.");
        }

        const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];
        const rawName = (playerState.name || "").trim();
        let existingForAccount = null;

        if (!hosgCurrentCharacterId && rawName) {
          const { data: rows, error: findErr } = await sb
            .from(HOSG_CHARACTERS_TABLE)
            .select("*")
            .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal)
            .ilike("name", rawName)
            .eq("is_deleted", false)
            .limit(1);

          if (findErr) {
            console.warn("[HOSG] Failed to look up hero by name", findErr);
          } else if (rows && rows.length > 0) {
            existingForAccount = rows[0];
          }
        }

        if (!hosgCurrentCharacterId && existingForAccount) {
          hosgCurrentCharacterId = existingForAccount[HOSG_CHARACTER_ID_COLUMN];

          if (!hosgCharacters) hosgCharacters = [];
          const idx = hosgCharacters.findIndex(
            (c) => c[HOSG_CHARACTER_ID_COLUMN] === hosgCurrentCharacterId
          );
          if (idx >= 0) {
            hosgCharacters[idx] = Object.assign(
              {},
              hosgCharacters[idx],
              hosgBuildCharacterUpdatePayloadFromState(playerState)
            );
          } else {
            hosgCharacters.push(
              Object.assign(
                {},
                existingForAccount,
                hosgBuildCharacterUpdatePayloadFromState(playerState)
              )
            );
          }
          hosgRefreshCharacterListUI();

          await hosgUpdateCharacterFromState(hosgCurrentCharacterId, playerState);
        } else if (!hosgCurrentCharacterId) {
          const activeCount = (hosgCharacters || []).filter((c) => !c.is_deleted).length;
          if (activeCount >= HOSG_MAX_CHARACTERS) {
            window.alert("You have reached the maximum number of heroes on this account. Delete one before creating a new hero.");
            return;
          }

          const created = await hosgCreateCharacterFromState(playerState);
          if (created && created[HOSG_CHARACTER_ID_COLUMN]) {
            hosgCurrentCharacterId = created[HOSG_CHARACTER_ID_COLUMN];
            if (!hosgCharacters) hosgCharacters = [];
            hosgCharacters.push(created);
            hosgRefreshCharacterListUI();
          }
        } else {
          await hosgUpdateCharacterFromState(hosgCurrentCharacterId, playerState);
          if (hosgCharacters) {
            for (let i = 0; i < hosgCharacters.length; i++) {
              if (hosgCharacters[i][HOSG_CHARACTER_ID_COLUMN] === hosgCurrentCharacterId) {
                hosgCharacters[i] = Object.assign(
                  {},
                  hosgCharacters[i],
                  hosgBuildCharacterUpdatePayloadFromState(playerState)
                );
                break;
              }
            }
          }
        }
      } catch (e) {
        console.warn("[HOSG] Failed to sync hero on start", e);
        window.alert(e && e.message ? e.message : "Could not sync hero to server.");
        return;
      }
    }

    if (hosgAccount && hosgAccount[HOSG_ACCOUNT_ID_COLUMN] != null) {
      playerState.accountId = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];
    }
    if (hosgCurrentCharacterId) {
      playerState.characterId = hosgCurrentCharacterId;
    }

    overlay.style.display = "none";
    savePlayerStateRuntime(
      null,
      playerState.stats.hp, playerState.stats.maxHp,
      playerState.stats.mp, playerState.stats.maxMp,
      playerState.stats.xp, playerState.stats.level
    );

    try {
      if (window.hosgConnectMultiplayerIfNeeded) {
        window.hosgConnectMultiplayerIfNeeded();
      }
    } catch (e) {
      console.warn("[HOSG] Multiplayer connect failed", e);
    }
  });

  nameInput.addEventListener("keydown", function (ev) {
    if (ev.key === "Enter") {
      startBtn.click();
    }
  });
}

function setupAccountAndCharacterFlows() {
  const accountOverlay = document.getElementById("account-overlay");
  const charOverlay = document.getElementById("char-create-overlay");

  const hasSupabase = hosgHasSupabaseConfig();

  if (!accountOverlay || !charOverlay || !hasSupabase) {
    if (accountOverlay) {
      accountOverlay.style.display = "none";
    }
    if (charOverlay) {
      charOverlay.style.display = "flex";
    }
    return;
  }

  charOverlay.style.display = "none";
  accountOverlay.style.display = "flex";

  const emailInput = document.getElementById("acct-email");
  const passwordInput = document.getElementById("acct-password");
  const signinBtn = document.getElementById("acct-signin");
  const signupBtn = document.getElementById("acct-signup");
  const msgEl = document.getElementById("acct-message");

  function setMessage(text) {
    if (!msgEl) return;
    msgEl.textContent = text || "";
  }

  async function handle(mode) {
    const email = emailInput && emailInput.value || "";
    const password = passwordInput && passwordInput.value || "";
    try {
      setMessage(mode === "signup" ? "Creating account..." : "Signing in...");
      const account = await hosgAuthWithEmailPassword(mode, email, password);
      if (!account) {
        setMessage("Authentication failed.");
        return;
      }
      setMessage("");
      if (accountOverlay) {
        accountOverlay.style.display = "none";
      }
      if (charOverlay) {
        charOverlay.style.display = "flex";
      }
      await hosgLoadCharacters();
    } catch (e) {
      console.warn("[HOSG] Account auth error", e);
      setMessage(e && e.message ? e.message : "Authentication failed.");
    }
  }

  if (signinBtn) {
    signinBtn.addEventListener("click", function () {
      handle("signin");
    });
  }
  if (signupBtn) {
    signupBtn.addEventListener("click", function () {
      handle("signup");
    });
  }
  if (passwordInput) {
    passwordInput.addEventListener("keydown", function (ev) {
      if (ev.key === "Enter") {
        handle("signin");
      }
    });
  }
}

loadPlayerState();
const isMobile = (typeof navigator !== "undefined" && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
(function () {

  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true,
    disableWebGL2Support: false
  });

const MP_SERVER_URL = (location.hostname === "localhost" || location.hostname === "127.0.0.1")
        ? "ws://localhost:8080"
        : "wss://hosg-u1hc.onrender.com";
let mpSocket = null;
let mpConnected = false;
let mpLocalId = null;
const remotePlayers = {};

function mpUpdateStatusLabel() {
  const el = document.getElementById("mp-status-text");
  if (!el) return;
  if (mpConnected) {
    el.textContent = "Online";
    el.classList.add("online");
    el.classList.remove("offline");
  } else {
    el.textContent = "Offline";
    el.classList.add("offline");
    el.classList.remove("online");
  }
}

function mpLog(msg) {
  console.log("[MP]", msg);
}

function mpHexToColor3(hex) {
  if (!hex || typeof hex !== "string") return new BABYLON.Color3(1, 1, 1);
  const h = hex.replace("#", "");
  if (h.length !== 6) return new BABYLON.Color3(1, 1, 1);
  const r = parseInt(h.substring(0, 2), 16) / 255;
  const g = parseInt(h.substring(2, 4), 16) / 255;
  const b = parseInt(h.substring(4, 6), 16) / 255;
  return new BABYLON.Color3(r, g, b);
}

function createRemoteHero(scene, shadowGenerator, id, player) {
  const root = new BABYLON.TransformNode("remoteRoot_" + id, scene);

  const body = BABYLON.MeshBuilder.CreateCapsule(
    "remoteBody_" + id,
    { height: 2.6, radius: 0.55, tessellation: 8, subdivisions: 1 },
    scene
  );
  body.parent = root;
  body.position = new BABYLON.Vector3(0, 1.4, 0);

  const head = BABYLON.MeshBuilder.CreateSphere(
    "remoteHead_" + id,
    { diameter: 0.85, segments: 8 },
    scene
  );
  head.parent = root;
  head.position = new BABYLON.Vector3(0, 2.4, 0);

  const tunicMat = new BABYLON.StandardMaterial("remoteTunic_" + id, scene);
  const pantsMat = new BABYLON.StandardMaterial("remotePants_" + id, scene);
  const skinMat = new BABYLON.StandardMaterial("remoteSkin_" + id, scene);

  const app = player.appearance || {};
  tunicMat.diffuseColor = mpHexToColor3(app.tunic || "#344fba");
  pantsMat.diffuseColor = mpHexToColor3(app.pants || "#1f2937");
  skinMat.diffuseColor = mpHexToColor3(app.skin || "#f3dec0");

  body.material = tunicMat;
  head.material = skinMat;

  shadowGenerator.addShadowCaster(body);
  shadowGenerator.addShadowCaster(head);

  const plate = BABYLON.MeshBuilder.CreatePlane(
    "remoteName_" + id,
    { width: 3, height: 0.6 },
    scene
  );
  plate.parent = root;
  plate.position = new BABYLON.Vector3(0, 3.1, 0);
  plate.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

  const tex = new BABYLON.DynamicTexture(
    "remoteNameTex_" + id,
    { width: 256, height: 64 },
    scene,
    false
  );
  tex.hasAlpha = true;
  const ctxName = (player.name || "Hero") + (player.role ? " ‚Äì " + player.role : "");
  tex.drawText(
    ctxName,
    null,
    42,
    "20px Segoe UI",
    "#ffffff",
    "transparent",
    true
  );
  const plateMat = new BABYLON.StandardMaterial("remoteNameMat_" + id, scene);
  plateMat.diffuseTexture = tex;
  plateMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
  plateMat.backFaceCulling = false;
  plate.material = plateMat;

  remotePlayers[id] = { root, body, head, plate, tex };
  return remotePlayers[id];
}

function updateRemoteHero(id, player) {
  const entry = remotePlayers[id];
  if (!entry) return;
  const p = player.position || { x: 0, y: 1.5, z: 0 };
  entry.root.position.x = p.x;
  entry.root.position.y = p.y - 1.5;
  entry.root.position.z = p.z;
  entry.root.rotation.y = player.rotationY || 0;
}

function removeRemoteHero(id) {
  const entry = remotePlayers[id];
  if (!entry) return;
  Object.values(entry).forEach(obj => {
    if (obj && obj.dispose) obj.dispose();
  });
  delete remotePlayers[id];
}

function setupMultiplayer(scene, heroBody, shadowGenerator, getRuntimeStats) {
  if (!("WebSocket" in window)) {
    mpLog("WebSocket not supported in this browser.");
    return;
  }
  try {
    mpSocket = new WebSocket(MP_SERVER_URL);
  } catch (e) {
    console.warn("Failed to create WebSocket", e);
    return;
  }

  mpSocket.addEventListener("open", function () {
    mpConnected = true;
    mpUpdateStatusLabel();
    mpLog("Connected to multiplayer server");
    if (!playerState) loadPlayerState();
    const hello = {
      type: "hello",
      player: playerState
    };
    mpSocket.send(JSON.stringify(hello));
  });

  mpSocket.addEventListener("close", function () {
    mpConnected = false;
    mpUpdateStatusLabel();
    mpLog("Disconnected from multiplayer server");
    Object.keys(remotePlayers).forEach(id => removeRemoteHero(id));
  });

  mpSocket.addEventListener("error", function (err) {
    console.warn("Multiplayer socket error", err);
    mpConnected = false;
    mpUpdateStatusLabel();
  });

  mpSocket.addEventListener("message", function (ev) {
    let msg;
    try {
      msg = JSON.parse(ev.data);
    } catch (e) {
      return;
    }
    if (!msg || !msg.type) return;

    switch (msg.type) {
      case "welcome": {
        mpLocalId = msg.id;
        const others = msg.players || [];
        others.forEach(entry => {
          if (entry.id === mpLocalId) return;
          if (!remotePlayers[entry.id]) {
            createRemoteHero(scene, shadowGenerator, entry.id, entry.player);
          }
          updateRemoteHero(entry.id, entry.player);
        });
        break;
      }
      case "playerJoined": {
        if (msg.id === mpLocalId) break;
        if (!remotePlayers[msg.id]) {
          createRemoteHero(scene, shadowGenerator, msg.id, msg.player);
        }
        updateRemoteHero(msg.id, msg.player);
        break;
      }
      case "playerLeft": {
        if (msg.id === mpLocalId) break;
        removeRemoteHero(msg.id);
        break;
      }
      case "state": {
        if (msg.id === mpLocalId) break;
        if (!remotePlayers[msg.id]) {
          createRemoteHero(scene, shadowGenerator, msg.id, msg.player);
        }
        updateRemoteHero(msg.id, msg.player);
        break;
      }
      case "chat": {
        if (msg.from && msg.text) {
          appendChat(msg.from + ": " + msg.text);
        }
        break;
      }
    }
  });

  return function sendLocalState() {
    if (!mpConnected || !mpSocket || mpSocket.readyState !== WebSocket.OPEN) return;
    const stats = getRuntimeStats();
    const payload = {
      type: "state",
      player: {
        name: playerState?.name,
        role: playerState?.role,
        appearance: playerState?.appearance,
        position: stats.position,
        rotationY: stats.rotationY,
        accountId: playerState?.accountId || null,
        characterId: playerState?.characterId || null,
        stats: {
          hp: stats.hp,
          maxHp: stats.maxHp,
          mp: stats.mp,
          maxMp: stats.maxMp,
          xp: stats.xp,
          level: stats.level
        }
      }
    };
    try {
      mpSocket.send(JSON.stringify(payload));
    } catch (e) {
      console.warn("Failed to send state", e);
    }
  };
}

function appendChat(text) {
  const log = document.getElementById("chat-log");
  const line = document.createElement("div");
  line.textContent = text;
  log.appendChild(line);
  log.scrollTop = log.scrollHeight;
}

(function setupChat() {
  const input = document.getElementById("chat-input");
  const send = document.getElementById("chat-send");

  function sendMessage() {
    const value = input.value.trim();
    if (!value) return;

    if (mpConnected && mpSocket && mpSocket.readyState === WebSocket.OPEN) {
      const msg = {
        type: "chat",
        text: value
      };
      try {
        mpSocket.send(JSON.stringify(msg));
      } catch (e) {
        console.warn("Failed to send chat", e);
      }
    } else {
      appendChat("You: " + value);
    }

    input.value = "";
  }

  send.addEventListener("click", sendMessage);
  input.addEventListener("keydown", function (ev) {
    if (ev.key === "Enter") {
      sendMessage();
    }
  });

  appendChat("System: Type to chat. If connected to the multiplayer server, your messages will be sent to other players.");
})();

const createScene = function () {
  const scene = new BABYLON.Scene(engine);
  scene.gravity = new BABYLON.Vector3(0, -0.5, 0);
  scene.collisionsEnabled = true;

  // Initialize game systems
  GameSystems.init(scene, hosgSupabase);

  const envTex = new BABYLON.CubeTexture(
    "https://playground.babylonjs.com/textures/environment.env",
    scene
  );
  scene.environmentTexture = envTex;
  scene.createDefaultSkybox(envTex, true, 1000);

  const camera = new BABYLON.ArcRotateCamera(
    "camera",
    -Math.PI / 2,
    0.9,
    40,
    new BABYLON.Vector3(0, 3, 0),
    scene
  );
  camera.lowerRadiusLimit = 18;
  camera.upperRadiusLimit = 70;
  camera.wheelDeltaPercentage = 0.02;
  camera.panningSensibility = 0;
  camera.attachControl(canvas, true);
  camera.checkCollisions = false;

  const hemiLight = new BABYLON.HemisphericLight(
    "hemi",
    new BABYLON.Vector3(0, 1, 0),
    scene
  );
  hemiLight.intensity = 0.6;

  const sun = new BABYLON.DirectionalLight(
    "sun",
    new BABYLON.Vector3(-0.5, -1, -0.3),
    scene
  );
  sun.position = new BABYLON.Vector3(60, 80, 60);
  sun.intensity = 1.1;

  const shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
  shadowGenerator.useBlurExponentialShadowMap = true;
  shadowGenerator.blurKernel = 16;
  scene.shadowGenerator = shadowGenerator;

  const ground = BABYLON.MeshBuilder.CreateGround(
    "ground",
    { width: 220, height: 220, subdivisions: 80 },
    scene
  );
  ground.checkCollisions = true;
  const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
  groundMat.diffuseTexture = new BABYLON.Texture(
    "https://playground.babylonjs.com/textures/grass.jpg",
    scene
  );
  groundMat.diffuseTexture.uScale = 40;
  groundMat.diffuseTexture.vScale = 40;
  groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
  ground.material = groundMat;
  ground.receiveShadows = true;

  const water = BABYLON.MeshBuilder.CreateGround(
    "water",
    { width: 80, height: 80, subdivisions: 2 },
    scene
  );
  water.position = new BABYLON.Vector3(0, 0.02, -60);
  const waterMat = new BABYLON.StandardMaterial("waterMat", scene);
  waterMat.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.6);
  waterMat.alpha = 0.6;
  waterMat.specularColor = new BABYLON.Color3(0.6, 0.8, 1);
  waterMat.backFaceCulling = false;
  water.material = waterMat;

  const stonePathMat = new BABYLON.StandardMaterial("stoneMat", scene);
  stonePathMat.diffuseTexture = new BABYLON.Texture(
    "https://playground.babylonjs.com/textures/rock.png",
    scene
  );
  stonePathMat.diffuseTexture.uScale = 4;
  stonePathMat.diffuseTexture.vScale = 4;
  stonePathMat.specularColor = new BABYLON.Color3(0.02, 0.02, 0.02);

  for (let i = -30; i <= 30; i += 5) {
    const stone = BABYLON.MeshBuilder.CreateBox(
      "pathStone",
      { width: 2.5, height: 0.4, depth: 2.5 },
      scene
    );
    stone.position = new BABYLON.Vector3(i, 0.2, 0);
    stone.material = stonePathMat;
    stone.checkCollisions = true;
    stone.receiveShadows = true;
  }

  const treeTrunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
  treeTrunkMat.diffuseTexture = new BABYLON.Texture(
    "https://playground.babylonjs.com/textures/wood.jpg",
    scene
  );
  treeTrunkMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

  const treeLeafMat = new BABYLON.StandardMaterial("leafMat", scene);
  treeLeafMat.diffuseColor = new BABYLON.Color3(0.22, 0.45, 0.2);
  treeLeafMat.emissiveColor = new BABYLON.Color3(0.03, 0.08, 0.03);

  function createTree(x, z, scale) {
    const trunk = BABYLON.MeshBuilder.CreateCylinder(
      "trunk",
      { height: 6 * scale, diameterTop: 0.8 * scale, diameterBottom: 1.2 * scale },
      scene
    );
    trunk.position = new BABYLON.Vector3(x, 3 * scale, z);
    trunk.material = treeTrunkMat;
    trunk.checkCollisions = true;
    trunk.receiveShadows = true;

    const canopy = BABYLON.MeshBuilder.CreateSphere(
      "canopy",
      { diameter: 6 * scale, segments: 8 },
      scene
    );
    canopy.position = new BABYLON.Vector3(x, 6.5 * scale, z);
    canopy.material = treeLeafMat;
    canopy.checkCollisions = true;
    canopy.receiveShadows = true;

    shadowGenerator.addShadowCaster(trunk);
    shadowGenerator.addShadowCaster(canopy);
  }

  for (let i = 0; i < 80; i++) {
    const radius = 80 + Math.random() * 30;
    const angle = Math.random() * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    const scale = 0.6 + Math.random() * 0.8;
    createTree(x, z, scale);
  }

  const townMat = new BABYLON.StandardMaterial("townMat", scene);
  townMat.diffuseTexture = new BABYLON.Texture(
    "https://playground.babylonjs.com/textures/floor.png",
    scene
  );
  townMat.diffuseTexture.uScale = 4;
  townMat.diffuseTexture.vScale = 4;

  const plaza = BABYLON.MeshBuilder.CreateBox(
    "plaza",
    { width: 40, depth: 40, height: 1 },
    scene
  );
  plaza.position = new BABYLON.Vector3(0, 0.5, 30);
  plaza.material = townMat;
  plaza.checkCollisions = true;
  plaza.receiveShadows = true;

  const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
  wallMat.diffuseTexture = new BABYLON.Texture(
    "https://playground.babylonjs.com/textures/floor.png",
    scene
  );
  wallMat.diffuseTexture.uScale = 2;
  wallMat.diffuseTexture.vScale = 1;

  function createWall(from, to, height, thickness) {
    const length = BABYLON.Vector3.Distance(from, to);
    const wall = BABYLON.MeshBuilder.CreateBox(
      "wall",
      { width: length, depth: thickness, height: height },
      scene
    );
    wall.position = from.add(to).scale(0.5);
    wall.position.y = height / 2;
    const dir = to.subtract(from);
    wall.rotation.y = Math.atan2(dir.z, dir.x);
    wall.material = wallMat;
    wall.checkCollisions = true;
    wall.receiveShadows = true;
    shadowGenerator.addShadowCaster(wall);
  }

  const half = 20;
  const height = 5;
  const thickness = 1;
  createWall(
    new BABYLON.Vector3(-half, 0, 30 - half),
    new BABYLON.Vector3(half, 0, 30 - half),
    height,
    thickness
  );
  createWall(
    new BABYLON.Vector3(-half, 0, 30 + half),
    new BABYLON.Vector3(half, 0, 30 + half),
    height,
    thickness
  );
  createWall(
    new BABYLON.Vector3(-half, 0, 30 - half),
    new BABYLON.Vector3(-half, 0, 30 + half),
    height,
    thickness
  );
  createWall(
    new BABYLON.Vector3(half, 0, 30 - half),
    new BABYLON.Vector3(half, 0, 30 + half),
    height,
    thickness
  );

  let heroBody = BABYLON.MeshBuilder.CreateCapsule(
    "heroBody",
    {
      height: 2.8,
      radius: 0.6,
      tessellation: 10,
      subdivisions: 2
    },
    scene
  );
  heroBody.position = new BABYLON.Vector3(
    playerState.position.x,
    playerState.position.y,
    playerState.position.z
  );
  heroBody.rotation.y = playerState.rotationY || 0;

  heroBody.ellipsoid = new BABYLON.Vector3(0.8, 1.4, 0.8);
  heroBody.ellipsoidOffset = new BABYLON.Vector3(0, 1.4, 0);
  heroBody.checkCollisions = true;
  heroBody.applyGravity = true;
  heroBody.visibility = 0.0;
  scene.heroBody = heroBody;

  const heroSkinMat = new BABYLON.StandardMaterial("heroSkinMat", scene);
  const heroClothMat = new BABYLON.StandardMaterial("heroClothMat", scene);
  const heroPantsMat = new BABYLON.StandardMaterial("heroPantsMat", scene);
  const heroBootMat = new BABYLON.StandardMaterial("heroBootMat", scene);

  applyAppearanceToMaterials(scene, {
    skin: heroSkinMat,
    tunic: heroClothMat,
    pants: heroPantsMat,
    boots: heroBootMat
  });

  heroSkinMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

  const heroVisualRoot = new BABYLON.TransformNode("heroVisualRoot", scene);
  heroVisualRoot.parent = heroBody;
  heroVisualRoot.position = new BABYLON.Vector3(0, -0.4, 0);

  const heroRig = {
    root: heroVisualRoot,
    torso: null,
    head: null,
    shoulders: null,
    hips: null,
    leftArmJoint: null,
    rightArmJoint: null,
    leftLegJoint: null,
    rightLegJoint: null
  };

  const torso = BABYLON.MeshBuilder.CreateBox(
    "heroTorso",
    { width: 1.1, height: 2, depth: 0.7 },
    scene
  );
  torso.parent = heroVisualRoot;
  torso.position = new BABYLON.Vector3(0, 1.6, 0);
  torso.material = heroClothMat;
  heroRig.torso = torso;

  const head = BABYLON.MeshBuilder.CreateSphere(
    "heroHead",
    { diameter: 0.9, segments: 8 },
    scene
  );
  head.parent = torso;
  head.position = new BABYLON.Vector3(0, 1.4, 0);
  head.material = heroSkinMat;
  heroRig.head = head;

  const hips = new BABYLON.TransformNode("heroHips", scene);
  hips.parent = heroVisualRoot;
  hips.position = new BABYLON.Vector3(0, 0.8, 0);
  heroRig.hips = hips;

  function createLeg(name, xSign) {
    const joint = new BABYLON.TransformNode(name + "Joint", scene);
    joint.parent = hips;
    joint.position = new BABYLON.Vector3(0.35 * xSign, 0, 0);

    const upper = BABYLON.MeshBuilder.CreateBox(
      name + "Upper",
      { width: 0.4, height: 1.7, depth: 0.4 },
      scene
    );
    upper.parent = joint;
    upper.position = new BABYLON.Vector3(0, -0.85, 0);
    upper.material = heroPantsMat;

    const boot = BABYLON.MeshBuilder.CreateBox(
      name + "Boot",
      { width: 0.5, height: 0.4, depth: 0.7 },
      scene
    );
    boot.parent = joint;
    boot.position = new BABYLON.Vector3(0, -1.7, 0.12);
    boot.material = heroBootMat;

    shadowGenerator.addShadowCaster(upper);
    shadowGenerator.addShadowCaster(boot);

    return joint;
  }

  heroRig.leftLegJoint = createLeg("heroLeftLeg", -1);
  heroRig.rightLegJoint = createLeg("heroRightLeg", 1);

  const shoulders = new BABYLON.TransformNode("heroShoulders", scene);
  shoulders.parent = torso;
  shoulders.position = new BABYLON.Vector3(0, 1.1, 0);
  heroRig.shoulders = shoulders;

  function createArm(name, xSign) {
    const joint = new BABYLON.TransformNode(name + "Joint", scene);
    joint.parent = shoulders;
    joint.position = new BABYLON.Vector3(0.75 * xSign, 0.1, 0);

    const upper = BABYLON.MeshBuilder.CreateBox(
      name + "Upper",
      { width: 0.35, height: 1.4, depth: 0.35 },
      scene
    );
    upper.parent = joint;
    upper.position = new BABYLON.Vector3(0, -0.7, 0);
    upper.material = heroClothMat;

    const hand = BABYLON.MeshBuilder.CreateBox(
      name + "Hand",
      { width: 0.3, height: 0.4, depth: 0.3 },
      scene
    );
    hand.parent = joint;
    hand.position = new BABYLON.Vector3(0, -1.25, 0);
    hand.material = heroSkinMat;

    shadowGenerator.addShadowCaster(upper);
    shadowGenerator.addShadowCaster(hand);

    return joint;
  }

  heroRig.leftArmJoint = createArm("heroLeftArm", -1);
  heroRig.rightArmJoint = createArm("heroRightArm", 1);

  shadowGenerator.addShadowCaster(torso);
  shadowGenerator.addShadowCaster(head);

  camera.target = heroBody.position.add(new BABYLON.Vector3(0, 2, 0));
  const hudHeroName = document.getElementById("hud-hero-name");
  if (hudHeroName && playerState && playerState.name) {
    hudHeroName.textContent = playerState.name + " of Shady Grove";
  }

  const npcMat = new BABYLON.StandardMaterial("npcMat", scene);
  npcMat.diffuseColor = new BABYLON.Color3(0.4, 0.7, 1.0);
  npcMat.emissiveColor = new BABYLON.Color3(0.03, 0.05, 0.09);

  function createNpc(name, position) {
    const npc = BABYLON.MeshBuilder.CreateBox(
      name,
      { width: 1.6, height: 3, depth: 1.2 },
      scene
    );
    npc.position = position.clone();
    npc.material = npcMat;
    npc.checkCollisions = true;
    npc.isPickable = true;
    shadowGenerator.addShadowCaster(npc);

    const plane = BABYLON.MeshBuilder.CreatePlane(
      name + "_nameplate",
      { width: 3, height: 0.6 },
      scene
    );
    plane.parent = npc;
    plane.position = new BABYLON.Vector3(0, 2.2, 0);
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

    const dynamicTex = new BABYLON.DynamicTexture(
      name + "_dt",
      { width: 256, height: 64 },
      scene,
      false
    );
    dynamicTex.hasAlpha = true;
    dynamicTex.drawText(
      name,
      null,
      42,
      "20px Segoe UI",
      "#ffffff",
      "transparent",
      true
    );

    const planeMat = new BABYLON.StandardMaterial(name + "_nameMat", scene);
    planeMat.diffuseTexture = dynamicTex;
    planeMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
    planeMat.backFaceCulling = false;
    plane.material = planeMat;

    return npc;
  }

  createNpc("Mennonite Merchant", new BABYLON.Vector3(4, 1.5, 34));
  createNpc("Village Guard", new BABYLON.Vector3(-6, 1.5, 26));

  // Spawn test enemies asynchronously (loads real 3D models!)
  GameSystems.spawnTestEnemies(scene).then(() => {
    console.log('[HOSG] ‚úì All test enemies spawned with 3D models!');
  }).catch(err => {
    console.error('[HOSG] Error spawning enemies:', err);
  });

  const inputMap = {};
  window.addEventListener("keydown", function (ev) {
    if (!ev || typeof ev.key !== "string") return;
    const key = ev.key.toLowerCase();
    inputMap[key] = true;
  });
  window.addEventListener("keyup", function (ev) {
    if (!ev || typeof ev.key !== "string") return;
    const key = ev.key.toLowerCase();
    inputMap[key] = false;
  });
  const mobileControls = document.getElementById("mobile-controls");
  const joystickBase = document.getElementById("joystick-base");
  const joystickThumb = document.getElementById("joystick-thumb");
  const btnJump = document.getElementById("btn-jump");
  const btnRun = document.getElementById("btn-run");

  const joystick = { x: 0, y: 0, active: false };
  let mobileRunHeld = false;
  let mobileJumpQueued = false;

  if (isMobile && mobileControls && joystickBase && joystickThumb && btnJump && btnRun) {
    mobileControls.style.display = "flex";

    let activeTouchId = null;
    const maxRadius = 60;

    function resetJoystick() {
      joystick.active = false;
      joystick.x = 0;
      joystick.y = 0;
      activeTouchId = null;
      joystickThumb.style.transform = "translate(-50%, -50%)";
    }

    function updateJoystickFromTouch(touch) {
      const rect = joystickBase.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const dx = touch.clientX - centerX;
      const dy = touch.clientY - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      let clampedDx = dx;
      let clampedDy = dy;

      if (distance > maxRadius) {
        const ratio = maxRadius / distance;
        clampedDx *= ratio;
        clampedDy *= ratio;
      }

      joystickThumb.style.transform = "translate(" + clampedDx + "px, " + clampedDy + "px)";
      joystick.x = clampedDx / maxRadius;
      joystick.y = clampedDy / maxRadius;
      joystick.active = true;
    }

    joystickBase.addEventListener("touchstart", function (e) {
      e.preventDefault();
      const t = e.changedTouches[0];
      activeTouchId = t.identifier;
      updateJoystickFromTouch(t);
    }, { passive: false });

    joystickBase.addEventListener("touchmove", function (e) {
      e.preventDefault();
      if (activeTouchId === null) return;
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === activeTouchId) {
          updateJoystickFromTouch(t);
          break;
        }
      }
    }, { passive: false });

    joystickBase.addEventListener("touchend", function (e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === activeTouchId) {
          resetJoystick();
          break;
        }
      }
    }, { passive: false });

    joystickBase.addEventListener("touchcancel", function (e) {
      e.preventDefault();
      resetJoystick();
    }, { passive: false });

    btnJump.addEventListener("touchstart", function (e) {
      e.preventDefault();
      mobileJumpQueued = true;
    }, { passive: false });

    btnRun.addEventListener("touchstart", function (e) {
      e.preventDefault();
      mobileRunHeld = true;
    }, { passive: false });

    btnRun.addEventListener("touchend", function (e) {
      e.preventDefault();
      mobileRunHeld = false;
    }, { passive: false });

    btnRun.addEventListener("touchcancel", function (e) {
      e.preventDefault();
      mobileRunHeld = false;
    }, { passive: false });
  }

  const gamepadState = {
    hasPad: false,
    moveX: 0,
    moveY: 0,
    lookX: 0,
    lookY: 0,
    run: false,
    jump: false,
    lastJump: false
  };

  function updateGamepadState() {
    const getGamepads = navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads;
    if (!getGamepads) {
      gamepadState.hasPad = false;
      return;
    }
    const pads = getGamepads.call(navigator);
    let pad = null;
    for (let i = 0; i < pads.length; i++) {
      if (pads[i]) { pad = pads[i]; break; }
    }
    if (!pad) {
      gamepadState.hasPad = false;
      gamepadState.moveX = gamepadState.moveY = gamepadState.lookX = gamepadState.lookY = 0;
      gamepadState.run = gamepadState.jump = false;
      return;
    }
    gamepadState.hasPad = true;
    const axes = pad.axes || [];
    const buttons = pad.buttons || [];
    const dead = 0.2;
    function d(v) { return Math.abs(v) < dead ? 0 : v; }
    const lx = d(axes[0] || 0);
    const ly = d(axes[1] || 0);
    const rx = d(axes[2] || 0);
    const ry = d(axes[3] || 0);
    gamepadState.moveX = lx;
    gamepadState.moveY = ly;
    gamepadState.lookX = rx;
    gamepadState.lookY = ry;
    const jumpNow = buttons[0] && buttons[0].pressed;
    gamepadState.run = (buttons[1] && buttons[1].pressed) || (buttons[4] && buttons[4].pressed) || (buttons[5] && buttons[5].pressed);
    gamepadState.jump = !gamepadState.lastJump && !!jumpNow;
    gamepadState.lastJump = !!jumpNow;
  }

  function wrapAngle(a) {
    while (a > Math.PI) a -= Math.PI * 2;
    while (a < -Math.PI) a += Math.PI * 2;
    return a;
  }

  let hudTime = 0;
  const hpFill = document.getElementById("hp-fill");
  const mpFill = document.getElementById("mp-fill");
  const hpLabel = document.getElementById("hp-label");
  const mpLabel = document.getElementById("mp-label");
  const xpFill = document.getElementById("xp-fill");
  const xpLabel = document.getElementById("xp-label");
  const levelLabel = document.getElementById("level-label");

  function updateHud(time) {
    if (hp > maxHp) hp = maxHp;
    if (hp < 0) hp = 0;
    if (mp > maxMp) mp = maxMp;
    if (mp < 0) mp = 0;
    hpFill.style.width = (hp / maxHp * 100) + "%";
    mpFill.style.width = (mp / maxMp * 100) + "%";
    xpFill.style.width = Math.min(100, xp) + "%";
    hpLabel.textContent = Math.round(hp) + " / " + maxHp;
    mpLabel.textContent = Math.round(mp) + " / " + maxMp;
    xpLabel.textContent = Math.round(xp) + "%";
    levelLabel.textContent = level;
  }

  const baseSpeed = 0.16;
  const runMultiplier = 1.8;
  const rotationLerp = 0.18;
  let verticalVelocity = 0;
  const jumpStrength = 0.22;
  let isGrounded = false;

  let walkCycleTime = 0;
  let autosaveTimer = 0;
  let netSendTimer = 0;

  scene.onBeforeRenderObservable.add(function () {
    const deltaTime = scene.getEngine().getDeltaTime();
    const dt = deltaTime / (1000 / 60);
    const dtSec = deltaTime / 1000;

    hudTime += dtSec;
    updateHud(hudTime);
    updateGamepadState();

    autosaveTimer += dtSec;
    netSendTimer += dtSec;

    // Update NPC AI
    const playerData = {
      id: hosgCurrentCharacterId || 'player_local',
      name: playerState?.name || "Hero",
      position: heroBody.position.clone(),
      stats: { hp, maxHp, mp, maxMp, level, xp, attack: 10, defense: 5 }
    };
    GameSystems.npcManager.updateAI(dtSec, [playerData]);

    // Update target frame
    if (GameSystems.currentTarget && GameSystems.currentTarget.stats.hp > 0) {
      const target = GameSystems.currentTarget;
      document.getElementById('target-frame').style.display = 'block';
      document.getElementById('target-name').textContent = target.name;
      document.getElementById('target-hp-label').textContent = 
        Math.floor(target.stats.hp) + ' / ' + target.stats.maxHp;
      document.getElementById('target-hp-fill').style.width = 
        (target.stats.hp / target.stats.maxHp * 100) + '%';
    } else {
      document.getElementById('target-frame').style.display = 'none';
      if (GameSystems.currentTarget && GameSystems.currentTarget.stats.hp <= 0) {
        GameSystems.currentTarget = null;
      }
    }

    let heroSpeed = baseSpeed;
    if (inputMap["shift"] || (gamepadState.hasPad && gamepadState.run) || mobileRunHeld) {
      heroSpeed *= runMultiplier;
    }

    let moveX = 0;
    let moveZ = 0;

    if (inputMap["w"]) moveZ += 1;
    if (inputMap["s"]) moveZ -= 1;
    if (inputMap["d"]) moveX += 1;
    if (inputMap["a"]) moveX -= 1;

    if (joystick.active) {
      moveZ += -joystick.y;
      moveX += joystick.x;
    }

    if (gamepadState.hasPad) {
      moveZ += -gamepadState.moveY;
      moveX += gamepadState.moveX;
    }

    const moveMagnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
    let isMoving = moveMagnitude > 0.05;

    const jumpRequested = (inputMap[" "] || mobileJumpQueued || (gamepadState.hasPad && gamepadState.jump));
    if (jumpRequested && isGrounded) {
      verticalVelocity = jumpStrength;
      isGrounded = false;
    }
    mobileJumpQueued = false;

    verticalVelocity += scene.gravity.y * dtSec;
    let nextPos = heroBody.position.clone();
    nextPos.y += verticalVelocity * dt;

    if (nextPos.y < 1.5) {
      nextPos.y = 1.5;
      verticalVelocity = 0;
      isGrounded = true;
    }

    let moveVecWorld = new BABYLON.Vector3(0, 0, 0);
    if (isMoving) {
      const normX = moveX / moveMagnitude;
      const normZ = moveZ / moveMagnitude;

      let forwardDir = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
      forwardDir.y = 0;
      forwardDir.normalize();

      let rightDir = camera.getDirection(new BABYLON.Vector3(1, 0, 0));
      rightDir.y = 0;
      rightDir.normalize();

      moveVecWorld = forwardDir.scale(normZ).add(rightDir.scale(normX));
      moveVecWorld.normalize();

      const desiredY = Math.atan2(moveVecWorld.x, moveVecWorld.z);
      const angleDiff = wrapAngle(desiredY - heroBody.rotation.y);
      heroBody.rotation.y += angleDiff * rotationLerp * dt;
    }

    if (isMoving) {
      const displacement = moveVecWorld.scale(heroSpeed * dt);
      nextPos.addInPlace(displacement);
    }

    heroBody.moveWithCollisions(nextPos.subtract(heroBody.position));

    if (heroRig.root) {
      if (isMoving) {
        walkCycleTime += dtSec * (heroSpeed / baseSpeed) * 4.2;
        const phase = walkCycleTime * Math.PI * 2;
        const swing = Math.sin(phase);
        const swingOpp = Math.sin(phase + Math.PI);
        const legSwing = 0.7;
        const armSwing = 0.8;

        heroRig.leftLegJoint.rotation.x = swing * legSwing;
        heroRig.rightLegJoint.rotation.x = swingOpp * legSwing;
        heroRig.leftArmJoint.rotation.x = swingOpp * armSwing * 0.6;
        heroRig.rightArmJoint.rotation.x = swing * armSwing * 0.6;

        const bob = Math.abs(Math.sin(phase)) * 0.06;
        heroRig.torso.position.y = 1.6 + bob;
      } else {
        const relaxFactor = 1 - Math.pow(0.0001, dtSec);

        function dampJoint(joint) {
          joint.rotation.x -= joint.rotation.x * relaxFactor;
          joint.rotation.z -= joint.rotation.z * relaxFactor;
        }

        dampJoint(heroRig.leftLegJoint);
        dampJoint(heroRig.rightLegJoint);
        dampJoint(heroRig.leftArmJoint);
        dampJoint(heroRig.rightArmJoint);

        const baseTorsoY = 1.6;
        heroRig.torso.position.y += (baseTorsoY - heroRig.torso.position.y) * relaxFactor;

        walkCycleTime += dtSec * 0.5;
        const breath = Math.sin(walkCycleTime * Math.PI * 2) * 0.01;
        heroRig.torso.position.y = baseTorsoY + breath;
      }
    }

    camera.target = heroBody.position.add(new BABYLON.Vector3(0, 2, 0));

    if (gamepadState.hasPad) {
      const lookSpeed = 0.04;
      camera.alpha -= gamepadState.lookX * lookSpeed * dt;
      camera.beta -= gamepadState.lookY * lookSpeed * dt;
      const lowerBetaLimit = 0.3;
      const upperBetaLimit = Math.PI / 2;
      if (camera.beta < lowerBetaLimit) camera.beta = lowerBetaLimit;
      if (camera.beta > upperBetaLimit) camera.beta = upperBetaLimit;
    }

    if (autosaveTimer >= 0.5) {
      autosaveTimer = 0;
      savePlayerStateRuntime(
        heroBody,
        hp, maxHp,
        mp, maxMp,
        xp, level
      );
    }

    if (typeof mpSendLocalState === "function" && netSendTimer >= 0.1) {
      netSendTimer = 0;
      mpSendLocalState();
    }
  });

  scene.onPointerObservable.add(function (pointerInfo) {
    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK) {
      const pick = pointerInfo.pickInfo;
      if (pick.hit && pick.pickedMesh && pick.pickedMesh.name.includes("Mennonite")) {
        appendChat("Mennonite Merchant: 'Fresh bread and shiny swords! Trading coming soon.'");
      }
    }
  });

  return scene;
};

const scene = createScene();

setupCharacterCreationUI();
setupAccountAndCharacterFlows();

let mpSendLocalState = null;
mpUpdateStatusLabel();

function hosgConnectMultiplayerIfNeeded() {
  if (typeof mpSendLocalState === "function") {
    return;
  }
  if (!scene.heroBody || !scene.shadowGenerator) {
    return;
  }
  mpSendLocalState = setupMultiplayer(
    scene,
    scene.heroBody,
    scene.shadowGenerator,
    function getRuntimeStats() {
      return {
        position: {
          x: scene.heroBody.position.x,
          y: scene.heroBody.position.y,
          z: scene.heroBody.position.z
        },
        rotationY: scene.heroBody.rotation.y,
        hp,
        maxHp,
        mp,
        maxMp,
        xp,
        level
      };
    }
  );
}

window.hosgConnectMultiplayerIfNeeded = hosgConnectMultiplayerIfNeeded;

// ==================== COMBAT & TARGETING FUNCTIONS ====================
window.useHotbarSkill = async function(skillId) {
  if (!GameSystems.currentTarget) {
    appendChat("No target selected. Press Tab to target nearest enemy.");
    return;
  }
  
  if (GameSystems.currentTarget.stats.hp <= 0) {
    appendChat("Target is already dead.");
    GameSystems.currentTarget = null;
    clearTargetHighlight();
    return;
  }
  
  const playerData = {
    id: hosgCurrentCharacterId || 'player_local',
    name: playerState?.name || "Hero",
    position: scene.heroBody.position.clone(),
    stats: { hp, maxHp, mp, maxMp, level, xp, attack: 10, defense: 5 }
  };
  
  const result = await GameSystems.combat.useSkill(
    playerData,
    GameSystems.currentTarget,
    skillId
  );
  
  if (result.success) {
    mp = Math.max(0, mp - (GameSystems.combat.skills.get(skillId)?.mpCost || 0));
    
    const critText = result.isCritical ? " CRITICAL!" : "";
    appendChat(`You hit ${GameSystems.currentTarget.name} for ${result.damage} damage${critText}`);
    
    if (result.targetDied) {
      appendChat(`${GameSystems.currentTarget.name} has been defeated!`);
      const xpGain = GameSystems.currentTarget.stats.level * 10;
      const xpNeeded = 100 * Math.pow(level, 1.8);
      xp = Math.min(100, xp + (xpGain / xpNeeded) * 100);
      
      // Check level up
      if (xp >= 100) {
        level++;
        xp = 0;
        maxHp += 10;
        maxMp += 5;
        hp = maxHp;
        mp = maxMp;
        appendChat(`LEVEL UP! You are now level ${level}!`);
      }
      
      GameSystems.currentTarget = null;
      clearTargetHighlight();
    }
  } else {
    appendChat(result.reason);
  }
};

function targetNearestEnemy() {
  const enemies = GameSystems.npcManager.getEnemiesInRange(scene.heroBody.position, 30);
  if (enemies.length === 0) {
    appendChat("No enemies nearby.");
    return;
  }
  
  let nearest = enemies[0];
  let nearestDist = BABYLON.Vector3.Distance(scene.heroBody.position, nearest.position);
  
  for (const enemy of enemies) {
    if (enemy.stats.hp <= 0) continue;
    const dist = BABYLON.Vector3.Distance(scene.heroBody.position, enemy.position);
    if (dist < nearestDist) {
      nearest = enemy;
      nearestDist = dist;
    }
  }
  
  if (nearest.stats.hp <= 0) {
    appendChat("No living enemies nearby.");
    return;
  }
  
  GameSystems.currentTarget = nearest;
  highlightTarget(nearest);
  appendChat(`Targeted: ${nearest.name}`);
}

function highlightTarget(target) {
  clearTargetHighlight();
  
  const targetRing = BABYLON.MeshBuilder.CreateTorus("targetRing", {
    diameter: 3,
    thickness: 0.1,
    tessellation: 32
  }, scene);
  
  targetRing.position = target.mesh.root.position.clone();
  targetRing.position.y = 0.1;
  targetRing.rotation.x = Math.PI / 2;
  
  const mat = new BABYLON.StandardMaterial("targetMat", scene);
  mat.emissiveColor = new BABYLON.Color3(1, 0, 0);
  mat.disableLighting = true;
  targetRing.material = mat;
  
  const obs = scene.onBeforeRenderObservable.add(() => {
    const time = Date.now() / 1000;
    targetRing.scaling.setAll(1 + Math.sin(time * 3) * 0.1);
    if (target.mesh && target.mesh.root) {
      targetRing.position.x = target.mesh.root.position.x;
      targetRing.position.z = target.mesh.root.position.z;
    }
  });
  
  targetRing.metadata = { observer: obs };
  GameSystems.targetRing = targetRing;
}

function clearTargetHighlight() {
  if (GameSystems.targetRing) {
    if (GameSystems.targetRing.metadata?.observer) {
      scene.onBeforeRenderObservable.remove(GameSystems.targetRing.metadata.observer);
    }
    GameSystems.targetRing.dispose();
    GameSystems.targetRing = null;
  }
}

document.addEventListener('keydown', function(e) {
  if (e.key === 'Tab') {
    e.preventDefault();
    targetNearestEnemy();
  } else if (e.key === 'Escape') {
    GameSystems.currentTarget = null;
    clearTargetHighlight();
    appendChat("Target cleared.");
  } else if (e.key >= '1' && e.key <= '4') {
    window.useHotbarSkill(parseInt(e.key));
  }
});

scene.onPointerObservable.add(function(pointerInfo) {
  if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
    if (pointerInfo.event.button === 0) {
      const pick = pointerInfo.pickInfo;
      if (pick.hit && pick.pickedMesh) {
        const meshName = pick.pickedMesh.name;
        
        if (meshName.includes('enemy_')) {
          const parts = meshName.split('_');
          if (parts.length >= 3) {
            const enemyId = parts[0] + '_' + parts[1] + '_' + parts[2];
            const enemy = GameSystems.npcManager.getNPC(enemyId);
            
            if (enemy && enemy.stats.hp > 0) {
              GameSystems.currentTarget = enemy;
              highlightTarget(enemy);
              appendChat(`Targeted: ${enemy.name}`);
            }
          }
        }
      }
    }
  }
});

engine.runRenderLoop(function () {
  scene.render();
});

window.addEventListener("resize", function () {
  engine.resize();
});

})();
  </script>
</body>
</html>