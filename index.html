<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Heroes of Shady Grove v1.0.32</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #141826 0, #05060b 50%, #000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }

    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
      gap: 12px;
    }

    #hud-left, #hud-right {
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: auto;
    }

    .hud-panel {
      background: rgba(5, 5, 15, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(130, 180, 255, 0.4);
      padding: 8px 10px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(6px);
      min-width: 180px;
    }

    .hud-title {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 4px;
      color: #9bc3ff;
    }

    .bar {
      position: relative;
      width: 100%;
      height: 14px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.08);
      margin-bottom: 4px;
    }

    .bar-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 60%;
      border-radius: inherit;
      transition: width 0.15s linear;
    }

    #hp-fill {
      background: linear-gradient(90deg, #f74b4b, #ffb347);
      box-shadow: 0 0 10px rgba(247, 75, 75, 0.6);
    }

    #mp-fill {
      background: linear-gradient(90deg, #5b8dff, #b77bff);
      box-shadow: 0 0 10px rgba(91, 141, 255, 0.6);
    }

    .bar-label {
      font-size: 11px;
      opacity: 0.9;
      display: flex;
      justify-content: space-between;
      margin-top: 1px;
    }

    #xp-row {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 11px;
      margin-top: 2px;
      opacity: 0.9;
    }

    #xp-bar {
      flex: 1;
      height: 6px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.12);
      position: relative;
    }

    #xp-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 25%;
      border-radius: inherit;
      background: linear-gradient(90deg, #ffe164, #ff9f43);
      box-shadow: 0 0 6px rgba(255, 225, 100, 0.7);
    }

    #minimap {
      width: 180px;
      height: 180px;
      border-radius: 999px;
      border: 2px solid rgba(130, 180, 255, 0.8);
      background: radial-gradient(circle at 30% 30%, #3b5b4a, #12201b 55%, #050809 100%);
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 16px rgba(0, 0, 0, 0.7);
    }

    #minimap-center {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #ffe164;
      border: 1px solid #000;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px rgba(255, 225, 100, 0.8);
    }

    #minimap-border {
      position: absolute;
      inset: 6px;
      border-radius: inherit;
      border: 1px solid rgba(255, 255, 255, 0.35);
      pointer-events: none;
    }

    
#char-create-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, rgba(15, 20, 45, 0.96), rgba(3, 3, 8, 0.98));
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 20;
}

#char-create-card {
  width: 360px;
  max-width: 92%;
  background: rgba(4, 6, 18, 0.96);
  border-radius: 18px;
  padding: 18px 20px 16px;
  border: 1px solid rgba(130, 180, 255, 0.65);
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
}

#char-title {
  font-size: 20px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 4px;
  color: #ffe164;
  text-shadow: 0 0 10px rgba(255, 225, 100, 0.8);
}

#char-subtitle {
  font-size: 12px;
  text-align: center;
  margin-bottom: 12px;
  color: #cfd8ff;
}

.char-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
  font-size: 12px;
}

.char-field span {
  color: #9db8ff;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  font-size: 11px;
}

.char-field input,
.char-field select {
  padding: 6px 8px;
  border-radius: 8px;
  border: 1px solid rgba(130, 180, 255, 0.6);
  background: rgba(5, 8, 20, 0.96);
  color: #f5f5f5;
  font-size: 12px;
  outline: none;
}

#char-colors {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px;
  margin-bottom: 12px;
  font-size: 11px;
}

#char-colors label {
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: stretch;
}

#char-colors span {
  color: #9db8ff;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  font-size: 10px;
}

#char-colors input[type="color"] {
  width: 100%;
  height: 26px;
  padding: 0;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.7);
  background: transparent;
  cursor: pointer;
}

#char-buttons {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

#char-buttons button {
  flex: 1;
  padding: 7px 10px;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.8);
  background: radial-gradient(circle at 30% 0%, #4a7bff, #7a4aff);
  color: #fff;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.9);
}

#char-buttons button:hover {
  filter: brightness(1.1);
}

#char-note {
  font-size: 10px;
  color: #9da8d6;
  text-align: center;
}

#char-slot-wrapper {
  margin-top: 8px;
  margin-bottom: 10px;
  padding: 8px 10px;
  border-radius: 10px;
  background: rgba(8, 15, 40, 0.9);
  border: 1px solid rgba(130, 180, 255, 0.45);
  max-height: 180px;
  overflow-y: auto;
}

#char-slot-header {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #9db8ff;
  margin-bottom: 6px;
}

#char-slot-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.char-slot-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 6px;
  border-radius: 6px;
  background: rgba(12, 20, 52, 0.95);
  border: 1px solid rgba(60, 110, 200, 0.6);
}

.char-slot-main {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.char-slot-name {
  font-size: 12px;
  font-weight: 600;
  color: #e2e8ff;
}

.char-slot-meta {
  font-size: 10px;
  color: #9da8d6;
}

.char-slot-actions {
  display: flex;
  gap: 4px;
}

.char-slot-actions button {
  font-size: 10px;
  padding: 3px 6px;
  border-radius: 6px;
  border: 1px solid rgba(130, 180, 255, 0.7);
  background: linear-gradient(to bottom, #3047a0, #192044);
  color: #f8f9ff;
  cursor: pointer;
}

.char-slot-actions button:hover {
  filter: brightness(1.08);
}

.char-slot-empty {
  font-size: 11px;
  color: #9da8d6;
}

#char-slot-warning {
  margin-top: 4px;
  font-size: 10px;
  color: #ffdd89;
  text-align: right;
}

/* Account login overlay */
#account-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, rgba(15, 20, 45, 0.96), rgba(3, 3, 8, 0.98));
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 30;
}

#account-card {
  width: 320px;
  max-width: 92%;
  background: rgba(4, 6, 18, 0.96);
  border-radius: 18px;
  padding: 18px 20px 16px;
  border: 1px solid rgba(130, 180, 255, 0.65);
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
}

#acct-title {
  font-size: 20px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 4px;
  color: #ffe164;
  text-shadow: 0 0 10px rgba(255, 225, 100, 0.8);
}

#acct-subtitle {
  font-size: 12px;
  text-align: center;
  margin-bottom: 12px;
  color: #cfd8ff;
}

.acct-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 8px;
}

.acct-field span {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #9db8ff;
}

.acct-field input {
  height: 28px;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.8);
  padding: 0 10px;
  background: rgba(9, 13, 32, 0.95);
  color: #e2e8ff;
}

#acct-buttons {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

#acct-buttons button {
  flex: 1;
  height: 30px;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.9);
  background: linear-gradient(to bottom, #3c5ad8, #101632);
  color: #fdfbff;
  font-weight: 600;
  font-size: 12px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  cursor: pointer;
}

#acct-buttons button:hover {
  filter: brightness(1.08);
}

#acct-message {
  min-height: 16px;
  font-size: 11px;
  color: #ffb4b4;
  text-align: center;
}


    #chat-panel {
      position: fixed;
      left: 12px;
      bottom: 12px;
      width: 320px;
      max-width: calc(100% - 24px);
      background: rgba(0, 0, 0, 0.78);
      border-radius: 10px;
      border: 1px solid rgba(130, 180, 255, 0.4);
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.75);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 10;
      pointer-events: auto;
    }

    #chat-log {
      padding: 6px 8px;
      height: 120px;
      font-size: 11px;
      overflow-y: auto;
      color: #d8e4ff;
      background: rgba(5, 8, 18, 0.9);
    }

    #chat-input-row {
      display: flex;
      border-top: 1px solid rgba(130, 180, 255, 0.5);
      background: rgba(10, 14, 26, 0.96);
    }

    #chat-input {
      flex: 1;
      padding: 6px 8px;
      border: none;
      outline: none;
      background: transparent;
      color: #f5f5f5;
      font-size: 11px;
    }

    #chat-input::placeholder {
      color: rgba(200, 215, 240, 0.7);
    }

    #chat-send {
      padding: 0 10px;
      border: none;
      background: linear-gradient(135deg, #4a7bff, #7a4aff);
      color: #fff;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      border-radius: 0;
    }

    #chat-send:hover {
      filter: brightness(1.1);
    }

        #mp-status {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 11;
      background: rgba(5, 5, 15, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(130, 180, 255, 0.6);
      padding: 4px 10px;
      font-size: 11px;
      color: #cfd8ff;
      pointer-events: auto;
    }

    #mp-status-text.online {
      color: #6bff7b;
    }

    #mp-status-text.offline {
      color: #ff7070;
    }

    #helper-keys {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 10;
      background: rgba(5, 5, 15, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(130, 180, 255, 0.4);
      padding: 6px 10px;
      font-size: 11px;
      color: #cfd8ff;
      pointer-events: auto;
      max-width: 260px;
    }

    #helper-keys strong {
      color: #ffe164;
    }

    #mobile-controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 12px;
      display: none;
      justify-content: space-between;
      align-items: flex-end;
      z-index: 15;
      pointer-events: none;
    }

    #joystick-base {
      width: 140px;
      height: 140px;
      border-radius: 999px;
      border: 2px solid rgba(130, 180, 255, 0.8);
      background: radial-gradient(circle at 30% 30%, rgba(120, 200, 255, 0.25), rgba(5, 10, 20, 0.9));
      box-shadow: 0 0 16px rgba(0, 0, 0, 0.7);
      position: relative;
      pointer-events: auto;
      touch-action: none;
    }

    #joystick-thumb {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 56px;
      height: 56px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #ffe164, #c28b2b);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(255, 225, 100, 0.8);
    }

    #mobile-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
    }

    #mobile-buttons button {
      min-width: 86px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(130, 180, 255, 0.7);
      background: radial-gradient(circle at 30% 0%, #4a7bff, #7a4aff);
      color: #fff;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      box-shadow: 0 0 14px rgba(0, 0, 0, 0.8);
      cursor: pointer;
    }

    #mobile-buttons button:active {
      transform: scale(0.97);
      filter: brightness(1.1);
    }

    @media (max-width: 768px) {
      
#char-create-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, rgba(15, 20, 45, 0.96), rgba(3, 3, 8, 0.98));
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 20;
}

#char-create-card {
  width: 360px;
  max-width: 92%;
  background: rgba(4, 6, 18, 0.96);
  border-radius: 18px;
  padding: 18px 20px 16px;
  border: 1px solid rgba(130, 180, 255, 0.65);
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
}

#char-title {
  font-size: 20px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 4px;
  color: #ffe164;
  text-shadow: 0 0 10px rgba(255, 225, 100, 0.8);
}

#char-subtitle {
  font-size: 12px;
  text-align: center;
  margin-bottom: 12px;
  color: #cfd8ff;
}

.char-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 10px;
  font-size: 12px;
}

.char-field span {
  color: #9db8ff;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  font-size: 11px;
}

.char-field input,
.char-field select {
  padding: 6px 8px;
  border-radius: 8px;
  border: 1px solid rgba(130, 180, 255, 0.6);
  background: rgba(5, 8, 20, 0.96);
  color: #f5f5f5;
  font-size: 12px;
  outline: none;
}

#char-colors {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px;
  margin-bottom: 12px;
  font-size: 11px;
}

#char-colors label {
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: stretch;
}

#char-colors span {
  color: #9db8ff;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  font-size: 10px;
}

#char-colors input[type="color"] {
  width: 100%;
  height: 26px;
  padding: 0;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.7);
  background: transparent;
  cursor: pointer;
}

#char-buttons {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

#char-buttons button {
  flex: 1;
  padding: 7px 10px;
  border-radius: 999px;
  border: 1px solid rgba(130, 180, 255, 0.8);
  background: radial-gradient(circle at 30% 0%, #4a7bff, #7a4aff);
  color: #fff;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.9);
}

#char-buttons button:hover {
  filter: brightness(1.1);
}

#char-note {
  font-size: 10px;
  color: #9da8d6;
  text-align: center;
}

    #chat-panel {
        width: calc(100% - 24px);
      }
          #mp-status {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 11;
      background: rgba(5, 5, 15, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(130, 180, 255, 0.6);
      padding: 4px 10px;
      font-size: 11px;
      color: #cfd8ff;
      pointer-events: auto;
    }

    #mp-status-text.online {
      color: #6bff7b;
    }

    #mp-status-text.offline {
      color: #ff7070;
    }

    #helper-keys {
        display: none;
      }
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script src="hosg_config.js"></script>
<script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
</head>
<body>
  <!-- Game: Heroes of Shady Grove | Version: 1.0.31 -->

  <canvas id="renderCanvas"></canvas>

  <div id="hud">
    <div id="hud-left">
      <div class="hud-panel">
        <div class="hud-title"><span id="hud-hero-name">Felix of Shady Grove</span></div>
        <div class="bar">
          <div id="hp-fill" class="bar-fill"></div>
        </div>
        <div class="bar-label">
          <span>HP</span>
          <span id="hp-label">100 / 100</span>
        </div>
        <div class="bar">
          <div id="mp-fill" class="bar-fill"></div>
        </div>
        <div class="bar-label">
          <span>MP</span>
          <span id="mp-label">60 / 100</span>
        </div>
        <div id="xp-row">
          <span>Lv. <span id="level-label">1</span></span>
          <div id="xp-bar"><div id="xp-fill"></div></div>
          <span id="xp-label">25%</span>
        </div>
      </div>
    </div>
    <div id="hud-right">
      <div id="minimap" class="hud-panel">
        <div id="minimap-center"></div>
        <div id="minimap-border"></div>
      </div>
    </div>
  </div>



<div id="account-overlay">
  <div id="account-card">
    <div id="acct-title">Heroes of Shady Grove</div>
    <div id="acct-subtitle">Sign in or create an account</div>
    <label class="acct-field">
      <span>Email</span>
      <input id="acct-email" type="email" autocomplete="email" />
    </label>
    <label class="acct-field">
      <span>Password</span>
      <input id="acct-password" type="password" autocomplete="current-password" />
    </label>
    <div id="acct-buttons">
      <button id="acct-signin" type="button">Sign in</button>
      <button id="acct-signup" type="button">Create account</button>
    </div>
    <div id="acct-message"></div>
  </div>
</div>

<div id="char-create-overlay">
  <div id="char-create-card">
    <div id="char-title">Heroes of Shady Grove</div>
    <div id="char-subtitle">Create your hero</div>
    <div id="char-slot-wrapper">
      <div id="char-slot-header">Your heroes</div>
      <div id="char-slot-list"></div>
      <div id="char-slot-warning"></div>
    </div>
    <label class="char-field">
      <span>Name</span>
      <input id="cc-name" type="text" maxlength="16" placeholder="Felix" />
    </label>
    <label class="char-field">
      <span>Role</span>
      <select id="cc-role">
        <option value="Adventurer">Adventurer</option>
        <option value="Knight">Knight</option>
        <option value="Ranger">Ranger</option>
        <option value="Mage">Mage</option>
      </select>
    </label>
    <div id="char-colors">
      <label>
        <span>Tunic</span>
        <input id="cc-tunic" type="color" value="#344fba" />
      </label>
      <label>
        <span>Pants</span>
        <input id="cc-pants" type="color" value="#1f2937" />
      </label>
      <label>
        <span>Skin</span>
        <input id="cc-skin" type="color" value="#f3dec0" />
      </label>
    </div>
    <div id="char-buttons">
      <button id="cc-random">Randomize</button>
      <button id="cc-start">Enter the world</button>
    </div>
    <div id="char-note">Heroes are saved automatically; if an online account is configured, they also sync to the server.</div>
  </div>
</div>

  <div id="chat-panel">
    <div id="chat-log"></div>
    <div id="chat-input-row">
      <input id="chat-input" placeholder="Type to chat..." />
      <button id="chat-send">Send</button>
    </div>
  </div>

  <div id="mp-status">MP: <span id="mp-status-text">Offline</span></div>

  <div id="helper-keys">
    <div><strong>Controls</strong></div>
    <div>W / A / S / D – Move</div>
    <div>Right mouse drag – Orbit camera</div>
    <div>Shift / B – Run</div>
    <div>Space / A – Jump</div>
    <div>Scroll – Zoom camera</div>
  </div>

  <div id="mobile-controls">
    <div id="joystick-base">
      <div id="joystick-thumb"></div>
    </div>
    <div id="mobile-buttons">
      <button id="btn-jump">Jump</button>
      <button id="btn-run">Run</button>
    </div>
  </div>

  <script>

// NPC registry for the starting city and future zones

function hosgInteractWithNearestNpc() {
  if (!scene || !scene.meshes || !heroBody) return;
  let best = null;
  let bestDistSq = Number.POSITIVE_INFINITY;
  const heroPos = heroBody.position;
  const maxDistSq = 7 * 7;
  for (const mesh of scene.meshes) {
    if (!mesh || !mesh.metadata || !mesh.metadata.npcName) continue;
    const dx = mesh.position.x - heroPos.x;
    const dz = mesh.position.z - heroPos.z;
    const distSq = dx * dx + dz * dz;
    if (distSq < maxDistSq && distSq < bestDistSq) {
      bestDistSq = distSq;
      best = mesh;
    }
  }
  if (!best) return;
  const npcName = best.metadata.npcName;
  const def = hosgNpcDefinitions[npcName];
  if (!def) return;
  const lines = (def.lines && def.lines.length)
    ? def.lines
    : ["Hello, adventurer."];
  const line = lines[Math.floor(Math.random() * lines.length)];
  const label = def.role ? def.name + " (" + def.role + ")" : def.name;
  appendChat(label + ": " + line);
}

const hosgNpcDefinitions = {};

function hosgRegisterNpc(name, def) {
  if (!name) return null;
  const base = {
    name,
    role: "",
    kind: "citizen",
    lines: [
      "Hello, adventurer."
    ]
  };
  hosgNpcDefinitions[name] = Object.assign(base, def || {});
  return hosgNpcDefinitions[name];
}

// Persistent player state (for online-ready save structure)
const HOSG_SAVE_KEY = "hosg_player_v1";
let playerState = null;

// Online account & character persistence (Supabase-backed)
const HOSG_MAX_CHARACTERS = 10;

// These values must be provided at runtime, for example via:
// window.HOSG_SUPABASE_URL and window.HOSG_SUPABASE_ANON_KEY.
// We do NOT hard-code any secrets here.
const HOSG_SUPABASE_URL = (typeof window !== "undefined" && window.HOSG_SUPABASE_URL) ? window.HOSG_SUPABASE_URL : "";
const HOSG_SUPABASE_ANON_KEY = (typeof window !== "undefined" && window.HOSG_SUPABASE_ANON_KEY) ? window.HOSG_SUPABASE_ANON_KEY : "";

// Mapping to the persistent schema in Supabase.
const HOSG_ACCOUNTS_TABLE = "hosg_accounts";
const HOSG_ACCOUNT_ID_COLUMN = "id";
const HOSG_ACCOUNT_EMAIL_COLUMN = "email";
const HOSG_ACCOUNT_USERNAME_COLUMN = "username";
const HOSG_ACCOUNT_PASSWORD_HASH_COLUMN = "password_hash";

const HOSG_CHARACTERS_TABLE = "hosg_characters";
const HOSG_CHARACTER_ID_COLUMN = "id";
const HOSG_CHARACTER_ACCOUNT_ID_COLUMN = "account_id";

// Supabase runtime state
let hosgSupabase = null;
// Current logged-in account row from hosg_accounts
let hosgAccount = null;
// Characters loaded for that account (excluding soft-deleted)
let hosgCharacters = [];
// Current active character id from hosg_characters
let hosgCurrentCharacterId = null;
// Throttling timer so we don't spam updates
let hosgSupabaseSaveTimer = null;

function hosgHasSupabaseConfig() {
  try {
    return typeof window !== "undefined" &&
      typeof window.supabase !== "undefined" &&
      !!HOSG_SUPABASE_URL &&
      !!HOSG_SUPABASE_ANON_KEY;
  } catch (e) {
    return false;
  }
}

async function hosgEnsureSupabase() {
  if (!hosgHasSupabaseConfig()) return null;
  if (hosgSupabase) return hosgSupabase;
  try {
    hosgSupabase = window.supabase.createClient(
      HOSG_SUPABASE_URL,
      HOSG_SUPABASE_ANON_KEY,
      {
        auth: {
          persistSession: false,
          autoRefreshToken: false
        }
      }
    );
  } catch (e) {
    console.warn("[HOSG] Supabase init failed", e);
    hosgSupabase = null;
  }
  return hosgSupabase;
}

async function hosgHashPassword(plain) {
  try {
    if (window.crypto && window.crypto.subtle && window.TextEncoder) {
      const enc = new TextEncoder().encode(plain);
      const buf = await window.crypto.subtle.digest("SHA-256", enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2, "0")).join("");
    }
  } catch (e) {
    console.warn("[HOSG] Web Crypto unavailable, using fallback hash", e);
  }
  // Fallback very simple hash if subtle crypto is unavailable
  let h = 0;
  for (let i = 0; i < plain.length; i++) {
    h = (h * 31 + plain.charCodeAt(i)) >>> 0;
  }
  return h.toString(16);
}

async function hosgAuthWithEmailPassword(mode, email, password) {
  const sb = await hosgEnsureSupabase();
  if (!sb) {
    throw new Error("Online accounts are not available on this build.");
  }

  const trimmedEmail = (email || "").trim().toLowerCase();
  const trimmedPass = (password || "").trim();

  if (!trimmedEmail || !trimmedPass) {
    throw new Error("Please enter both email and password.");
  }

  const passwordHash = await hosgHashPassword(trimmedPass);

  if (mode === "signup") {
    // Check for existing account with this email
    const { data: existing, error: existingError } = await sb
      .from(HOSG_ACCOUNTS_TABLE)
      .select(HOSG_ACCOUNT_ID_COLUMN)
      .eq(HOSG_ACCOUNT_EMAIL_COLUMN, trimmedEmail)
      .limit(1);

    if (existingError) {
      console.warn("[HOSG] Account lookup failed", existingError);
      throw new Error("Could not check existing accounts.");
    }
    if (existing && existing.length > 0) {
      throw new Error("An account with that email already exists.");
    }

    // Derive a simple username from email prefix
    let username = trimmedEmail.split("@")[0] || trimmedEmail;
    username = username.slice(0, 24);

    const payload = {};
    payload[HOSG_ACCOUNT_EMAIL_COLUMN] = trimmedEmail;
    payload[HOSG_ACCOUNT_USERNAME_COLUMN] = username;
    payload[HOSG_ACCOUNT_PASSWORD_HASH_COLUMN] = passwordHash;

    const { data, error } = await sb
      .from(HOSG_ACCOUNTS_TABLE)
      .insert(payload)
      .select()
      .single();

    if (error) {
      console.warn("[HOSG] Account creation failed", error);
      throw new Error("Could not create account. Please try again.");
    }

    hosgAccount = data;
    // Optionally update last_login_at
    try {
      await sb
        .from(HOSG_ACCOUNTS_TABLE)
        .update({ last_login_at: new Date().toISOString() })
        .eq(HOSG_ACCOUNT_ID_COLUMN, hosgAccount[HOSG_ACCOUNT_ID_COLUMN]);
    } catch (e) {
      console.warn("[HOSG] Failed to update last_login_at on signup", e);
    }
    return hosgAccount;
  } else {
    // Sign in to an existing account
    const { data, error } = await sb
      .from(HOSG_ACCOUNTS_TABLE)
      .select("*")
      .eq(HOSG_ACCOUNT_EMAIL_COLUMN, trimmedEmail)
      .limit(1);

    if (error) {
      console.warn("[HOSG] Account lookup failed", error);
      throw new Error("Could not look up account.");
    }

    if (!data || data.length === 0) {
      throw new Error("Account not found.");
    }

    const account = data[0];
    const storedHash = account[HOSG_ACCOUNT_PASSWORD_HASH_COLUMN];
    if (!storedHash || storedHash !== passwordHash) {
      throw new Error("Incorrect password.");
    }

    hosgAccount = account;
    try {
      await sb
        .from(HOSG_ACCOUNTS_TABLE)
        .update({ last_login_at: new Date().toISOString() })
        .eq(HOSG_ACCOUNT_ID_COLUMN, hosgAccount[HOSG_ACCOUNT_ID_COLUMN]);
    } catch (e) {
      console.warn("[HOSG] Failed to update last_login_at on signin", e);
    }
    return hosgAccount;
  }
}

function hosgBuildCharacterUpdatePayloadFromState(state) {
  const s = state && state.stats ? state.stats : {};
  const pos = state && state.position ? state.position : {};
  const levelVal = (typeof s.level === "number") ? s.level : 1;
  const xpVal = (s.xp != null) ? s.xp : 0;
  const currentZoneId = (state && state.currentZoneId != null) ? state.currentZoneId : null;

  return {
    name: state && state.name ? state.name : "Unnamed hero",
    level: levelVal,
    xp: xpVal,
    appearance: state && state.appearance ? state.appearance : null,
    stats: s,
    position_x: pos.x != null ? pos.x : 0,
    position_y: pos.y != null ? pos.y : 0,
    position_z: pos.z != null ? pos.z : 0,
    rotation_y: typeof state.rotationY === "number" ? state.rotationY : 0,
    current_zone_id: currentZoneId,
    is_deleted: false
  };
}

function hosgBuildCharacterInsertPayloadFromState(state, accountId, slotIndex) {
  const base = hosgBuildCharacterUpdatePayloadFromState(state);
  base[HOSG_CHARACTER_ACCOUNT_ID_COLUMN] = accountId;
  base.slot_index = slotIndex;
  base.created_at = new Date().toISOString();
  base.updated_at = base.created_at;
  return base;
}

async function hosgCreateCharacterFromState(state) {
  const sb = await hosgEnsureSupabase();
  if (!sb || !hosgAccount) return null;

  const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];

  // Enforce unique hero names (case-insensitive, not counting soft-deleted heroes)
  const rawName = state && state.name ? String(state.name) : "";
  const trimmedName = rawName.trim();
  if (trimmedName) {
    const { data: existingByName, error: nameLookupError } = await sb
      .from(HOSG_CHARACTERS_TABLE)
      .select(HOSG_CHARACTER_ID_COLUMN)
      .ilike("name", trimmedName)
      .eq("is_deleted", false)
      .limit(1);

    if (nameLookupError) {
      console.warn("[HOSG] Character name lookup failed", nameLookupError);
      throw new Error("Could not check hero names. Please try again.");
    }
    if (existingByName && existingByName.length > 0) {
      throw new Error("A hero with that name already exists.");
    }
  }

  // Determine the next free slot index from 0..HOSG_MAX_CHARACTERS-1

  const usedSlots = (hosgCharacters || [])
    .filter(c => !c.is_deleted)
    .map(c => c.slot_index)
    .filter(v => typeof v === "number");

  let slotIndex = 0;
  while (usedSlots.includes(slotIndex) && slotIndex < HOSG_MAX_CHARACTERS) {
    slotIndex++;
  }
  if (slotIndex >= HOSG_MAX_CHARACTERS) {
    throw new Error("You have reached the maximum number of heroes on this account.");
  }

  const payload = hosgBuildCharacterInsertPayloadFromState(state, accountIdVal, slotIndex);

  const { data, error } = await sb
    .from(HOSG_CHARACTERS_TABLE)
    .insert(payload)
    .select()
    .single();

  if (error) {
    console.warn("[HOSG] Failed to create character", error);
    throw new Error("Could not create hero on the server.");
  }

  return data;
}

async function hosgUpdateCharacterFromState(id, state) {
  if (!id) return;
  const sb = await hosgEnsureSupabase();
  if (!sb || !hosgAccount) return;

  const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];

  // Enforce unique hero names on rename (case-insensitive, not counting this hero or soft-deleted heroes)
  const rawName = state && state.name ? String(state.name) : "";
  const trimmedName = rawName.trim();
  if (trimmedName) {
    const { data: existingByName, error: nameLookupError } = await sb
      .from(HOSG_CHARACTERS_TABLE)
      .select(HOSG_CHARACTER_ID_COLUMN)
      .ilike("name", trimmedName)
      .eq("is_deleted", false)
      .neq(HOSG_CHARACTER_ID_COLUMN, id)
      .limit(1);

    if (nameLookupError) {
      console.warn("[HOSG] Character name lookup failed (update)", nameLookupError);
      throw new Error("Could not check hero names. Please try again.");
    }
    if (existingByName && existingByName.length > 0) {
      throw new Error("A hero with that name already exists.");
    }
  }

  const payload = hosgBuildCharacterUpdatePayloadFromState(state);
  payload.updated_at = new Date().toISOString();

  const { error } = await sb
    .from(HOSG_CHARACTERS_TABLE)
    .update(payload)
    .eq(HOSG_CHARACTER_ID_COLUMN, id)
    .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal)
    .eq("is_deleted", false);

  if (error) {
    console.warn("[HOSG] Failed to update character", error);
  }
}

async function hosgLoadCharacters() {
  const sb = await hosgEnsureSupabase();
  if (!sb || !hosgAccount) {
    hosgCharacters = [];
    return [];
  }

  const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];

  const { data, error } = await sb
    .from(HOSG_CHARACTERS_TABLE)
    .select("*")
    .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal)
    .eq("is_deleted", false)
    .order("slot_index", { ascending: true });

  if (error) {
    console.warn("[HOSG] Failed to load characters", error);
    hosgCharacters = [];
    return [];
  }

  hosgCharacters = data || [];
  try {
    hosgRefreshCharacterListUI();
  } catch (e) {
    console.warn("[HOSG] Failed to refresh character list UI", e);
  }
  return hosgCharacters;
}

function hosgBuildPlayerStateFromCharacter(row) {
  const base = getDefaultPlayerState();
  const out = Object.assign({}, base);

  if (row && row.name) out.name = row.name;
  if (row && row.stats && typeof row.stats === "object") {
    out.stats = Object.assign({}, base.stats, row.stats);
  } else if (row) {
    // At minimum, map XP and level if present
    const s = Object.assign({}, base.stats);
    if (typeof row.level === "number") s.level = row.level;
    if (row.xp != null) s.xp = Number(row.xp);
    out.stats = s;
  }

  if (row && row.appearance && typeof row.appearance === "object") {
    out.appearance = Object.assign({}, base.appearance, row.appearance);
  }

  out.position = {
    x: row && row.position_x != null ? Number(row.position_x) : base.position.x,
    y: row && row.position_y != null ? Number(row.position_y) : base.position.y,
    z: row && row.position_z != null ? Number(row.position_z) : base.position.z
  };
  out.rotationY = row && row.rotation_y != null ? Number(row.rotation_y) : base.rotationY || 0;

  return out;
}

function hosgScheduleSupabaseCharacterSave() {
  if (!hosgHasSupabaseConfig() || !hosgAccount || !hosgCurrentCharacterId || !playerState) {
    return;
  }
  if (hosgSupabaseSaveTimer) return;

  hosgSupabaseSaveTimer = setTimeout(async function () {
    hosgSupabaseSaveTimer = null;
    try {
      await hosgUpdateCharacterFromState(hosgCurrentCharacterId, playerState);
    } catch (e) {
      console.warn("[HOSG] Failed to save character to Supabase", e);
    }
  }, 1000);
}

function hosgRefreshCharacterListUI() {
  const listEl = document.getElementById("char-slot-list");
  const warningEl = document.getElementById("char-slot-warning");
  if (!listEl || !warningEl) return;

  listEl.innerHTML = "";

  if (!hosgCharacters || hosgCharacters.length === 0) {
    const empty = document.createElement("div");
    empty.className = "char-slot-empty";
    empty.textContent = "No heroes yet. Create one below.";
    listEl.appendChild(empty);
  } else {
    hosgCharacters.forEach(function (c) {
      if (c.is_deleted) return;

      const row = document.createElement("div");
      row.className = "char-slot-row";

      const main = document.createElement("div");
      main.className = "char-slot-main";

      const nameEl = document.createElement("div");
      nameEl.className = "char-slot-name";
      nameEl.textContent = c.name || "Unnamed hero";

      const metaEl = document.createElement("div");
      metaEl.className = "char-slot-meta";
      const levelVal = (typeof c.level === "number") ? c.level :
        (c.stats && typeof c.stats.level === "number") ? c.stats.level : 1;
      metaEl.textContent = "Level " + levelVal + (c.current_zone_id ? " • Zone " + c.current_zone_id : "");

      main.appendChild(nameEl);
      main.appendChild(metaEl);

      const actions = document.createElement("div");
      actions.className = "char-slot-actions";

      const loadBtn = document.createElement("button");
      loadBtn.textContent = "Load";
      loadBtn.addEventListener("click", function () {
        try {
          hosgCurrentCharacterId = c[HOSG_CHARACTER_ID_COLUMN];
          playerState = hosgBuildPlayerStateFromCharacter(c);
          window.localStorage.setItem(HOSG_SAVE_KEY, JSON.stringify(playerState));
          if (typeof window.applyStateToCharacterForm === "function") {
            window.applyStateToCharacterForm();
          }
        } catch (e) {
          console.warn("[HOSG] Failed to load hero from slot", e);
        }
      });

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener("click", async function () {
        const ok = window.confirm("Delete this hero permanently? This cannot be undone.");
        if (!ok) return;
        try {
          const sb = await hosgEnsureSupabase();
          if (!sb || !hosgAccount) return;

          const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];
          const payload = {
            is_deleted: true,
            deleted_at: new Date().toISOString(),
            delete_reason: "Deleted from client"
          };

          const { error } = await sb
            .from(HOSG_CHARACTERS_TABLE)
            .update(payload)
            .eq(HOSG_CHARACTER_ID_COLUMN, c[HOSG_CHARACTER_ID_COLUMN])
            .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal);

          if (error) {
            console.warn("[HOSG] Failed to soft-delete character", error);
            return;
          }

          hosgCharacters = hosgCharacters.filter(function (ch) {
            return ch[HOSG_CHARACTER_ID_COLUMN] !== c[HOSG_CHARACTER_ID_COLUMN];
          });
          if (hosgCurrentCharacterId === c[HOSG_CHARACTER_ID_COLUMN]) {
            hosgCurrentCharacterId = null;
          }
          hosgRefreshCharacterListUI();
        } catch (e) {
          console.warn("[HOSG] Delete hero error", e);
        }
      });

      actions.appendChild(loadBtn);
      actions.appendChild(deleteBtn);

      row.appendChild(main);
      row.appendChild(actions);

      listEl.appendChild(row);
    });
  }

  const activeCount = (hosgCharacters || []).filter(function (c) {
    return !c.is_deleted;
  }).length;

  warningEl.textContent = "Heroes on this account: " + activeCount + " / " + HOSG_MAX_CHARACTERS;
  if (activeCount >= HOSG_MAX_CHARACTERS) {
    warningEl.textContent += " (maximum reached; delete one to create a new hero)";
  }
}



// Runtime stats shared across HUD & multiplayer payloads
let hp = 100, maxHp = 100;
let mp = 60, maxMp = 100;
let xp = 25, level = 1;


function getDefaultPlayerState() {
  return {
    name: "Felix",
    role: "Adventurer",
    appearance: {
      tunic: "#344fba",
      pants: "#1f2937",
      skin: "#f3dec0",
      boots: "#3b2313"
    },
    stats: {
      hp: 100,
      maxHp: 100,
      mp: 60,
      maxMp: 100,
      xp: 25,
      level: 1
    },
    position: { x: 0, y: 1.5, z: 0 },
    rotationY: 0
  };
}

function loadPlayerState() {
  try {
    const raw = window.localStorage.getItem(HOSG_SAVE_KEY);
    if (!raw) {
      playerState = getDefaultPlayerState();
      return;
    }
    const parsed = JSON.parse(raw);
    playerState = Object.assign(getDefaultPlayerState(), parsed);
    if (!playerState.appearance) playerState.appearance = getDefaultPlayerState().appearance;
    if (!playerState.stats) playerState.stats = getDefaultPlayerState().stats;
    if (!playerState.position) playerState.position = getDefaultPlayerState().position;
    if (typeof playerState.rotationY !== "number") playerState.rotationY = 0;
  } catch (e) {
    console.warn("Failed to load player state, using defaults", e);
    playerState = getDefaultPlayerState();
  }
}

function savePlayerStateRuntime(heroBody, hp, maxHp, mp, maxMp, xp, level) {
  if (!playerState) return;
  try {
    playerState.stats = { hp, maxHp, mp, maxMp, xp, level };
    if (heroBody && heroBody.position) {
      playerState.position = {
        x: heroBody.position.x,
        y: heroBody.position.y,
        z: heroBody.position.z
      };
      playerState.rotationY = heroBody.rotation.y;
    }
    window.localStorage.setItem(HOSG_SAVE_KEY, JSON.stringify(playerState));
    // Also schedule a debounced save to Supabase if online accounts are enabled
    hosgScheduleSupabaseCharacterSave();
  } catch (e) {
    console.warn("Failed to save player state", e);
  }
}

function applyAppearanceToMaterials(scene, mats) {
  if (!playerState || !playerState.appearance) return;
  const a = playerState.appearance;
  function hexToColor3(hex) {
    if (!hex || typeof hex !== "string") return new BABYLON.Color3(1, 1, 1);
    const h = hex.replace("#", "");
    if (h.length !== 6) return new BABYLON.Color3(1, 1, 1);
    const r = parseInt(h.substring(0, 2), 16) / 255;
    const g = parseInt(h.substring(2, 4), 16) / 255;
    const b = parseInt(h.substring(4, 6), 16) / 255;
    return new BABYLON.Color3(r, g, b);
  }
  if (mats.skin) mats.skin.diffuseColor = hexToColor3(a.skin);
  if (mats.tunic) mats.tunic.diffuseColor = hexToColor3(a.tunic);
  if (mats.pants) mats.pants.diffuseColor = hexToColor3(a.pants);
  if (mats.boots) mats.boots.diffuseColor = hexToColor3(a.boots);
}


function setupCharacterCreationUI() {
  const overlay = document.getElementById("char-create-overlay");
  if (!overlay) return;

  const nameInput = document.getElementById("cc-name");
  const roleSelect = document.getElementById("cc-role");
  const tunicInput = document.getElementById("cc-tunic");
  const pantsInput = document.getElementById("cc-pants");
  const skinInput = document.getElementById("cc-skin");
  const randomBtn = document.getElementById("cc-random");
  const startBtn = document.getElementById("cc-start");
  const hudName = document.getElementById("hud-hero-name");

  if (!playerState) loadPlayerState();

  function applyStateToForm() {
    if (!playerState) return;
    nameInput.value = playerState.name || "Felix";
    roleSelect.value = playerState.role || "Adventurer";
    const ap = playerState.appearance || {};
    tunicInput.value = ap.tunic || "#344fba";
    pantsInput.value = ap.pants || "#1f2937";
    skinInput.value = ap.skin || "#f3dec0";
  }

  // Pre-fill from state
  applyStateToForm();
  // Expose so the character slot list can update the form when loading a hero
  window.applyStateToCharacterForm = applyStateToForm;

  function randomColor() {
    const h = Math.floor(Math.random() * 360);
    const s = 40 + Math.random() * 40;
    const l = 40 + Math.random() * 10;
    const c = (1 - Math.abs(2 * l / 100 - 1)) * (s / 100);
    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    const m = l / 100 - c / 2;
    let r = 0, g = 0, b = 0;
    if (h < 60) { r = c; g = x; b = 0; }
    else if (h < 120) { r = x; g = c; b = 0; }
    else if (h < 180) { r = 0; g = c; b = x; }
    else if (h < 240) { r = 0; g = x; b = c; }
    else if (h < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return "#" + r.toString(16).padStart(2, "0") +
                 g.toString(16).padStart(2, "0") +
                 b.toString(16).padStart(2, "0");
  }

  randomBtn.addEventListener("click", function () {
    tunicInput.value = randomColor();
    pantsInput.value = randomColor();
  });

  function applyFromUI() {
    const name = (nameInput.value || "Felix").trim();
    const role = roleSelect.value || "Adventurer";
    const tunic = tunicInput.value || "#344fba";
    const pants = pantsInput.value || "#1f2937";
    const skin = skinInput.value || "#f3dec0";

    playerState.name = name;
    playerState.role = role;
    playerState.appearance = Object.assign({}, playerState.appearance || {}, {
      tunic, pants, skin
    });

    if (hudName) {
      hudName.textContent = name + " of Shady Grove";
    }
  }

  startBtn.addEventListener("click", async function () {
    applyFromUI();

    // If we have an online account, create or update the hero record before entering the world
    if (hosgHasSupabaseConfig() && hosgAccount && playerState) {
      try {
        const sb = await hosgEnsureSupabase();
        if (!sb) {
          throw new Error("Online accounts are not available on this build.");
        }

        const accountIdVal = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];

        // Normalize current hero name
        const rawName = (playerState.name || "").trim();
        let existingForAccount = null;

        // If we don't already have a selected character, see if THIS ACCOUNT
        // already has a hero with this name. If so, we treat this as "load hero"
        // instead of "create brand-new hero" to avoid the duplicate-name error.
        if (!hosgCurrentCharacterId && rawName) {
          const { data: rows, error: findErr } = await sb
            .from(HOSG_CHARACTERS_TABLE)
            .select("*")
            .eq(HOSG_CHARACTER_ACCOUNT_ID_COLUMN, accountIdVal)
            .ilike("name", rawName)
            .eq("is_deleted", false)
            .limit(1);

          if (findErr) {
            console.warn("[HOSG] Failed to look up hero by name", findErr);
          } else if (rows && rows.length > 0) {
            existingForAccount = rows[0];
          }
        }

        if (!hosgCurrentCharacterId && existingForAccount) {
          // Case 1: Hero with this name already exists on THIS account.
          // Reuse that hero instead of trying to create a new one.
          hosgCurrentCharacterId = existingForAccount[HOSG_CHARACTER_ID_COLUMN];

          // Keep local list in sync
          if (!hosgCharacters) hosgCharacters = [];
          const idx = hosgCharacters.findIndex(
            (c) => c[HOSG_CHARACTER_ID_COLUMN] === hosgCurrentCharacterId
          );
          if (idx >= 0) {
            hosgCharacters[idx] = Object.assign(
              {},
              hosgCharacters[idx],
              hosgBuildCharacterUpdatePayloadFromState(playerState)
            );
          } else {
            hosgCharacters.push(
              Object.assign(
                {},
                existingForAccount,
                hosgBuildCharacterUpdatePayloadFromState(playerState)
              )
            );
          }
          hosgRefreshCharacterListUI();

          // Persist the latest appearance/position/stats
          await hosgUpdateCharacterFromState(hosgCurrentCharacterId, playerState);
        } else if (!hosgCurrentCharacterId) {
          // Case 2: No hero selected and name is new for this account: create one.
          const activeCount = (hosgCharacters || []).filter((c) => !c.is_deleted).length;
          if (activeCount >= HOSG_MAX_CHARACTERS) {
            window.alert("You have reached the maximum number of heroes on this account. Delete one before creating a new hero.");
            return;
          }

          const created = await hosgCreateCharacterFromState(playerState);
          if (created && created[HOSG_CHARACTER_ID_COLUMN]) {
            hosgCurrentCharacterId = created[HOSG_CHARACTER_ID_COLUMN];
            if (!hosgCharacters) hosgCharacters = [];
            hosgCharacters.push(created);
            hosgRefreshCharacterListUI();
          }
        } else {
          // Case 3: We already have a current character: update it.
          await hosgUpdateCharacterFromState(hosgCurrentCharacterId, playerState);
          if (hosgCharacters) {
            for (let i = 0; i < hosgCharacters.length; i++) {
              if (hosgCharacters[i][HOSG_CHARACTER_ID_COLUMN] === hosgCurrentCharacterId) {
                hosgCharacters[i] = Object.assign(
                  {},
                  hosgCharacters[i],
                  hosgBuildCharacterUpdatePayloadFromState(playerState)
                );
                break;
              }
            }
          }
        }
      } catch (e) {
        console.warn("[HOSG] Failed to sync hero on start", e);
        window.alert(e && e.message ? e.message : "Could not sync hero to server.");
        return; // Don't enter the world if we couldn't sync the hero
      }
    }

    // Attach accountId / characterId to the in-memory player state
    if (hosgAccount && hosgAccount[HOSG_ACCOUNT_ID_COLUMN] != null) {
      playerState.accountId = hosgAccount[HOSG_ACCOUNT_ID_COLUMN];
    }
    if (hosgCurrentCharacterId) {
      playerState.characterId = hosgCurrentCharacterId;
    }

      overlay.style.display = "none";
  // Initial save so the hero exists even if they immediately close the page
  savePlayerStateRuntime(
    null,
    playerState.stats.hp, playerState.stats.maxHp,
    playerState.stats.mp, playerState.stats.maxMp,
    playerState.stats.xp, playerState.stats.level
  );

  // Now that the hero is synced and active, connect this tab to the multiplayer server.
  try {
    if (window.hosgConnectMultiplayerIfNeeded) {
      window.hosgConnectMultiplayerIfNeeded();
    }
  } catch (e) {
    console.warn("[HOSG] Multiplayer connect failed", e);
  }
});



  // If we already have a saved hero, let them just hit Enter quickly
  nameInput.addEventListener("keydown", function (ev) {
    if (ev.key === "Enter") {
      startBtn.click();
    }
  });
}




function setupAccountAndCharacterFlows() {
  const accountOverlay = document.getElementById("account-overlay");
  const charOverlay = document.getElementById("char-create-overlay");

  const hasSupabase = hosgHasSupabaseConfig();

  // If we don't have Supabase configured, just hide the account overlay and
  // show the character creator like before.
  if (!accountOverlay || !charOverlay || !hasSupabase) {
    if (accountOverlay) {
      accountOverlay.style.display = "none";
    }
    if (charOverlay) {
      charOverlay.style.display = "flex";
    }
    return;
  }

  // Online mode: force login before character selection
  charOverlay.style.display = "none";
  accountOverlay.style.display = "flex";

  const emailInput = document.getElementById("acct-email");
  const passwordInput = document.getElementById("acct-password");
  const signinBtn = document.getElementById("acct-signin");
  const signupBtn = document.getElementById("acct-signup");
  const msgEl = document.getElementById("acct-message");

  function setMessage(text) {
    if (!msgEl) return;
    msgEl.textContent = text || "";
  }

  async function handle(mode) {
    const email = emailInput && emailInput.value || "";
    const password = passwordInput && passwordInput.value || "";
    try {
      setMessage(mode === "signup" ? "Creating account..." : "Signing in...");
      const account = await hosgAuthWithEmailPassword(mode, email, password);
      if (!account) {
        setMessage("Authentication failed.");
        return;
      }
      setMessage("");
      if (accountOverlay) {
        accountOverlay.style.display = "none";
      }
      if (charOverlay) {
        charOverlay.style.display = "flex";
      }
      // Load characters for this account into the slot UI
      await hosgLoadCharacters();
    } catch (e) {
      console.warn("[HOSG] Account auth error", e);
      setMessage(e && e.message ? e.message : "Authentication failed.");
    }
  }

  if (signinBtn) {
    signinBtn.addEventListener("click", function () {
      handle("signin");
    });
  }
  if (signupBtn) {
    signupBtn.addEventListener("click", function () {
      handle("signup");
    });
  }
  if (passwordInput) {
    passwordInput.addEventListener("keydown", function (ev) {
      if (ev.key === "Enter") {
        handle("signin");
      }
    });
  }
}



loadPlayerState();
    const isMobile = (typeof navigator !== "undefined" && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
    (function () {

      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true, {
        preserveDrawingBuffer: true,
        stencil: true,
        disableWebGL2Support: false
      });

// --- Multiplayer networking (client) ---
const MP_SERVER_URL = (location.hostname === "localhost" || location.hostname === "127.0.0.1")
        ? "ws://localhost:8080"
        : "wss://hosg-u1hc.onrender.com";
let mpSocket = null;
let mpConnected = false;
let mpLocalId = null;
const remotePlayers = {}; // id -> { body, head, nameplate, labelTex }

function mpUpdateStatusLabel() {
  const el = document.getElementById("mp-status-text");
  if (!el) return;
  if (mpConnected) {
    el.textContent = "Online";
    el.classList.add("online");
    el.classList.remove("offline");
  } else {
    el.textContent = "Offline";
    el.classList.add("offline");
    el.classList.remove("online");
  }
}

function mpLog(msg) {
  console.log("[MP]", msg);
}

function mpHexToColor3(hex) {
  if (!hex || typeof hex !== "string") return new BABYLON.Color3(1, 1, 1);
  const h = hex.replace("#", "");
  if (h.length !== 6) return new BABYLON.Color3(1, 1, 1);
  const r = parseInt(h.substring(0, 2), 16) / 255;
  const g = parseInt(h.substring(2, 4), 16) / 255;
  const b = parseInt(h.substring(4, 6), 16) / 255;
  return new BABYLON.Color3(r, g, b);
}

function createRemoteHero(scene, shadowGenerator, id, player) {
  const root = new BABYLON.TransformNode("remoteRoot_" + id, scene);

  const body = BABYLON.MeshBuilder.CreateCapsule(
    "remoteBody_" + id,
    { height: 2.6, radius: 0.55, tessellation: 8, subdivisions: 1 },
    scene
  );
  body.parent = root;
  body.position = new BABYLON.Vector3(0, 1.4, 0);

  const head = BABYLON.MeshBuilder.CreateSphere(
    "remoteHead_" + id,
    { diameter: 0.85, segments: 8 },
    scene
  );
  head.parent = root;
  head.position = new BABYLON.Vector3(0, 2.4, 0);

  const tunicMat = new BABYLON.StandardMaterial("remoteTunic_" + id, scene);
  const pantsMat = new BABYLON.StandardMaterial("remotePants_" + id, scene);
  const skinMat = new BABYLON.StandardMaterial("remoteSkin_" + id, scene);

  const app = player.appearance || {};
  tunicMat.diffuseColor = mpHexToColor3(app.tunic || "#344fba");
  pantsMat.diffuseColor = mpHexToColor3(app.pants || "#1f2937");
  skinMat.diffuseColor = mpHexToColor3(app.skin || "#f3dec0");

  body.material = tunicMat;
  head.material = skinMat;

  shadowGenerator.addShadowCaster(body);
  shadowGenerator.addShadowCaster(head);

  // Floating name label
  const plate = BABYLON.MeshBuilder.CreatePlane(
    "remoteName_" + id,
    { width: 3, height: 0.6 },
    scene
  );
  plate.parent = root;
  plate.position = new BABYLON.Vector3(0, 3.1, 0);
  plate.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

  const tex = new BABYLON.DynamicTexture(
    "remoteNameTex_" + id,
    { width: 256, height: 64 },
    scene,
    false
  );
  tex.hasAlpha = true;
  const ctxName = (player.name || "Hero") + (player.role ? " — " + player.role : "");
  tex.drawText(
    ctxName,
    null,
    42,
    "20px Segoe UI",
    "#ffffff",
    "transparent",
    true
  );
  const plateMat = new BABYLON.StandardMaterial("remoteNameMat_" + id, scene);
  plateMat.diffuseTexture = tex;
  plateMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
  plateMat.backFaceCulling = false;
  plate.material = plateMat;

  remotePlayers[id] = { root, body, head, plate, tex };
  return remotePlayers[id];
}

function updateRemoteHero(id, player) {
  const entry = remotePlayers[id];
  if (!entry) return;
  const p = player.position || { x: 0, y: 1.5, z: 0 };
  entry.root.position.x = p.x;
  entry.root.position.y = p.y - 1.5;
  entry.root.position.z = p.z;
  entry.root.rotation.y = player.rotationY || 0;
}

function removeRemoteHero(id) {
  const entry = remotePlayers[id];
  if (!entry) return;
  Object.values(entry).forEach(obj => {
    if (obj && obj.dispose) obj.dispose();
  });
  delete remotePlayers[id];
}

function setupMultiplayer(scene, heroBody, shadowGenerator, getRuntimeStats) {
  if (!("WebSocket" in window)) {
    mpLog("WebSocket not supported in this browser.");
    return;
  }
  try {
    mpSocket = new WebSocket(MP_SERVER_URL);
  } catch (e) {
    console.warn("Failed to create WebSocket", e);
    return;
  }

  mpSocket.addEventListener("open", function () {
    mpConnected = true;
    mpUpdateStatusLabel();
    mpLog("Connected to multiplayer server");
    if (!playerState) loadPlayerState();
    const hello = {
      type: "hello",
      player: playerState
    };
    mpSocket.send(JSON.stringify(hello));
  });

  mpSocket.addEventListener("close", function () {
    mpConnected = false;
    mpUpdateStatusLabel();
    mpLog("Disconnected from multiplayer server");
    // Clean up remote heroes
    Object.keys(remotePlayers).forEach(id => removeRemoteHero(id));
  });

  mpSocket.addEventListener("error", function (err) {
    console.warn("Multiplayer socket error", err);
    mpConnected = false;
    mpUpdateStatusLabel();
  });

  mpSocket.addEventListener("message", function (ev) {
    let msg;
    try {
      msg = JSON.parse(ev.data);
    } catch (e) {
      return;
    }
    if (!msg || !msg.type) return;

    switch (msg.type) {
      case "welcome": {
        mpLocalId = msg.id;
        const others = msg.players || [];
        others.forEach(entry => {
          if (entry.id === mpLocalId) return;
          if (!remotePlayers[entry.id]) {
            createRemoteHero(scene, shadowGenerator, entry.id, entry.player);
          }
          updateRemoteHero(entry.id, entry.player);
        });
        break;
      }
      case "playerJoined": {
        if (msg.id === mpLocalId) break;
        if (!remotePlayers[msg.id]) {
          createRemoteHero(scene, shadowGenerator, msg.id, msg.player);
        }
        updateRemoteHero(msg.id, msg.player);
        break;
      }
      case "playerLeft": {
        if (msg.id === mpLocalId) break;
        removeRemoteHero(msg.id);
        break;
      }
      case "state": {
        if (msg.id === mpLocalId) break;
        if (!remotePlayers[msg.id]) {
          createRemoteHero(scene, shadowGenerator, msg.id, msg.player);
        }
        updateRemoteHero(msg.id, msg.player);
        break;
      }
      case "chat": {
        if (msg.from && msg.text) {
          appendChat(msg.from + ": " + msg.text);
        }
        break;
      }
    }
  });

  // Return a function to send our current state periodically
  return function sendLocalState() {
    if (!mpConnected || !mpSocket || mpSocket.readyState !== WebSocket.OPEN) return;
    const stats = getRuntimeStats();
    const payload = {
      type: "state",
      player: {
        name: playerState?.name,
        role: playerState?.role,
        appearance: playerState?.appearance,
        position: stats.position,
        rotationY: stats.rotationY,
        accountId: playerState?.accountId || null,
        characterId: playerState?.characterId || null,
        stats: {
          hp: stats.hp,
          maxHp: stats.maxHp,
          mp: stats.mp,
          maxMp: stats.maxMp,
          xp: stats.xp,
          level: stats.level
        }
      }
    };
    try {
      mpSocket.send(JSON.stringify(payload));
    } catch (e) {
      console.warn("Failed to send state", e);
    }
  };
}
      function appendChat(text) {
        const log = document.getElementById("chat-log");
        const line = document.createElement("div");
        line.textContent = text;
        log.appendChild(line);
        log.scrollTop = log.scrollHeight;
      }

      (function setupChat() {
        const input = document.getElementById("chat-input");
        const send = document.getElementById("chat-send");

        function sendMessage() {
          const value = input.value.trim();
          if (!value) return;

          // If connected to multiplayer, send chat over the network
          if (mpConnected && mpSocket && mpSocket.readyState === WebSocket.OPEN) {
            const msg = {
              type: "chat",
              text: value
            };
            try {
              mpSocket.send(JSON.stringify(msg));
            } catch (e) {
              console.warn("Failed to send chat", e);
            }
          } else {
            appendChat("You: " + value);
          }

          input.value = "";
        }

        send.addEventListener("click", sendMessage);
        input.addEventListener("keydown", function (ev) {
          if (ev.key === "Enter") {
            sendMessage();
          }
        });

        appendChat("System: Type to chat. If connected to the multiplayer server, your messages will be sent to other players.");
      })();

      const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.gravity = new BABYLON.Vector3(0, -0.5, 0);
        scene.collisionsEnabled = true;

        const envTex = new BABYLON.CubeTexture(
          "https://playground.babylonjs.com/textures/environment.env",
          scene
        );
        scene.environmentTexture = envTex;
        scene.createDefaultSkybox(envTex, true, 1000);

        const camera = new BABYLON.ArcRotateCamera(
          "camera",
          -Math.PI / 2,
          0.9,
          40,
          new BABYLON.Vector3(0, 3, 0),
          scene
        );
        camera.lowerRadiusLimit = 18;
        camera.upperRadiusLimit = 70;
        camera.wheelDeltaPercentage = 0.02;
        camera.panningSensibility = 0;
        camera.attachControl(canvas, true);
        camera.checkCollisions = false;

        const hemiLight = new BABYLON.HemisphericLight(
          "hemi",
          new BABYLON.Vector3(0, 1, 0),
          scene
        );
        hemiLight.intensity = 0.6;

        const sun = new BABYLON.DirectionalLight(
          "sun",
          new BABYLON.Vector3(-0.5, -1, -0.3),
          scene
        );
        sun.position = new BABYLON.Vector3(60, 80, 60);
        sun.intensity = 1.1;

        const shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
        shadowGenerator.useBlurExponentialShadowMap = true;
        shadowGenerator.blurKernel = 16;
        scene.shadowGenerator = shadowGenerator;

        // World: ground, water, trees, simple town plaza
        const ground = BABYLON.MeshBuilder.CreateGround(
          "ground",
          { width: 220, height: 220, subdivisions: 80 },
          scene
        );
        ground.checkCollisions = true;
        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
        groundMat.diffuseTexture = new BABYLON.Texture(
          "https://playground.babylonjs.com/textures/grass.jpg",
          scene
        );
        groundMat.diffuseTexture.uScale = 40;
        groundMat.diffuseTexture.vScale = 40;
        groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
        ground.material = groundMat;
        ground.receiveShadows = true;

        const water = BABYLON.MeshBuilder.CreateGround(
          "water",
          { width: 80, height: 80, subdivisions: 2 },
          scene
        );
        water.position = new BABYLON.Vector3(0, 0.02, -60);
        const waterMat = new BABYLON.StandardMaterial("waterMat", scene);
        waterMat.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.6);
        waterMat.alpha = 0.6;
        waterMat.specularColor = new BABYLON.Color3(0.6, 0.8, 1);
        waterMat.backFaceCulling = false;
        water.material = waterMat;

        const stonePathMat = new BABYLON.StandardMaterial("stoneMat", scene);
        stonePathMat.diffuseTexture = new BABYLON.Texture(
          "https://playground.babylonjs.com/textures/rock.png",
          scene
        );
        stonePathMat.diffuseTexture.uScale = 4;
        stonePathMat.diffuseTexture.vScale = 4;
        stonePathMat.specularColor = new BABYLON.Color3(0.02, 0.02, 0.02);

        for (let i = -30; i <= 30; i += 5) {
          const stone = BABYLON.MeshBuilder.CreateBox(
            "pathStone",
            { width: 2.5, height: 0.4, depth: 2.5 },
            scene
          );
          stone.position = new BABYLON.Vector3(i, 0.2, 0);
          stone.material = stonePathMat;
          stone.checkCollisions = true;
          stone.receiveShadows = true;
        }

        const treeTrunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
        treeTrunkMat.diffuseTexture = new BABYLON.Texture(
          "https://playground.babylonjs.com/textures/wood.jpg",
          scene
        );
        treeTrunkMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

        const treeLeafMat = new BABYLON.StandardMaterial("leafMat", scene);
        treeLeafMat.diffuseColor = new BABYLON.Color3(0.22, 0.45, 0.2);
        treeLeafMat.emissiveColor = new BABYLON.Color3(0.03, 0.08, 0.03);

        function createTree(x, z, scale) {
          const trunk = BABYLON.MeshBuilder.CreateCylinder(
            "trunk",
            { height: 6 * scale, diameterTop: 0.8 * scale, diameterBottom: 1.2 * scale },
            scene
          );
          trunk.position = new BABYLON.Vector3(x, 3 * scale, z);
          trunk.material = treeTrunkMat;
          trunk.checkCollisions = true;
          trunk.receiveShadows = true;

          const canopy = BABYLON.MeshBuilder.CreateSphere(
            "canopy",
            { diameter: 6 * scale, segments: 8 },
            scene
          );
          canopy.position = new BABYLON.Vector3(x, 6.5 * scale, z);
          canopy.material = treeLeafMat;
          canopy.checkCollisions = true;
          canopy.receiveShadows = true;

          shadowGenerator.addShadowCaster(trunk);
          shadowGenerator.addShadowCaster(canopy);
        }

        for (let i = 0; i < 80; i++) {
          const radius = 80 + Math.random() * 30;
          const angle = Math.random() * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          const scale = 0.6 + Math.random() * 0.8;
          createTree(x, z, scale);
        }

        const townMat = new BABYLON.StandardMaterial("townMat", scene);
        townMat.diffuseTexture = new BABYLON.Texture(
          "https://playground.babylonjs.com/textures/floor.png",
          scene
        );
        townMat.diffuseTexture.uScale = 4;
        townMat.diffuseTexture.vScale = 4;

        const plaza = BABYLON.MeshBuilder.CreateBox(
          "plaza",
          { width: 40, depth: 40, height: 1 },
          scene
        );
        plaza.position = new BABYLON.Vector3(0, 0.5, 30);
        plaza.material = townMat;
        plaza.checkCollisions = true;
        plaza.receiveShadows = true;

        const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
        wallMat.diffuseTexture = new BABYLON.Texture(
          "https://playground.babylonjs.com/textures/floor.png",
          scene
        );
        wallMat.diffuseTexture.uScale = 2;
        wallMat.diffuseTexture.vScale = 1;

        function createWall(from, to, height, thickness) {
          const length = BABYLON.Vector3.Distance(from, to);
          const wall = BABYLON.MeshBuilder.CreateBox(
            "wall",
            { width: length, depth: thickness, height: height },
            scene
          );
          wall.position = from.add(to).scale(0.5);
          wall.position.y = height / 2;
          const dir = to.subtract(from);
          wall.rotation.y = Math.atan2(dir.z, dir.x);
          wall.material = wallMat;
          wall.checkCollisions = true;
          wall.receiveShadows = true;
          shadowGenerator.addShadowCaster(wall);
        }

        const half = 20;
        const height = 5;
        const thickness = 1;
        createWall(
          new BABYLON.Vector3(-half, 0, 30 - half),
          new BABYLON.Vector3(half, 0, 30 - half),
          height,
          thickness
        );
        createWall(
          new BABYLON.Vector3(-half, 0, 30 + half),
          new BABYLON.Vector3(half, 0, 30 + half),
          height,
          thickness
        );
        createWall(
          new BABYLON.Vector3(-half, 0, 30 - half),
          new BABYLON.Vector3(-half, 0, 30 + half),
          height,
          thickness
        );
        createWall(
          new BABYLON.Vector3(half, 0, 30 - half),
          new BABYLON.Vector3(half, 0, 30 + half),
          height,
          thickness
        );

        
// ----- GRAND STARTING CITY: Shady Grove Landing -----
const cityBuildingMat = new BABYLON.StandardMaterial("cityBuildingMat", scene);
cityBuildingMat.diffuseColor = new BABYLON.Color3(0.78, 0.74, 0.65);
cityBuildingMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

const cityRoofMat = new BABYLON.StandardMaterial("cityRoofMat", scene);
cityRoofMat.diffuseColor = new BABYLON.Color3(0.42, 0.18, 0.12);
cityRoofMat.specularColor = new BABYLON.Color3(0.06, 0.06, 0.06);

const cityAccentMat = new BABYLON.StandardMaterial("cityAccentMat", scene);
cityAccentMat.diffuseColor = new BABYLON.Color3(0.86, 0.82, 0.72);
cityAccentMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

const cityBannerMat = new BABYLON.StandardMaterial("cityBannerMat", scene);
cityBannerMat.diffuseColor = new BABYLON.Color3(0.18, 0.32, 0.68);
cityBannerMat.emissiveColor = new BABYLON.Color3(0.02, 0.05, 0.15);

function createCityHouse(name, center, width, depth, height, floors) {
  const base = BABYLON.MeshBuilder.CreateBox(
    name + "_base",
    { width, depth, height },
    scene
  );
  base.position = center.clone();
  base.position.y = height / 2;
  base.material = cityBuildingMat;
  base.checkCollisions = true;
  base.receiveShadows = true;
  shadowGenerator.addShadowCaster(base);

  const roof = BABYLON.MeshBuilder.CreateBox(
    name + "_roof",
    { width: width * 1.02, depth: depth * 1.02, height: height * 0.45 },
    scene
  );
  roof.position = center.clone();
  roof.position.y = height + (height * 0.25);
  roof.rotation.z = Math.PI / 18;
  roof.material = cityRoofMat;
  roof.checkCollisions = false;
  roof.receiveShadows = true;
  shadowGenerator.addShadowCaster(roof);

  if (floors && floors > 1) {
    for (let f = 1; f < floors; f++) {
      const upper = BABYLON.MeshBuilder.CreateBox(
        name + "_floor_" + f,
        { width: width * 0.9, depth: depth * 0.9, height: height * 0.7 },
        scene
      );
      upper.position = center.clone();
      upper.position.y = height / 2 + f * (height * 0.9);
      upper.material = cityBuildingMat;
      upper.checkCollisions = true;
      upper.receiveShadows = true;
      shadowGenerator.addShadowCaster(upper);
    }
  }

  const trim = BABYLON.MeshBuilder.CreateBox(
    name + "_trim",
    { width: width * 1.02, depth: depth * 1.02, height: 0.4 },
    scene
  );
  trim.position = new BABYLON.Vector3(center.x, 0.2, center.z);
  trim.material = cityAccentMat;
  trim.checkCollisions = false;
  trim.receiveShadows = true;
  shadowGenerator.addShadowCaster(trim);

  return base;
}

function createCityTower(name, center, radius, height) {
  const tower = BABYLON.MeshBuilder.CreateCylinder(
    name + "_tower",
    { diameter: radius * 2, height },
    scene
  );
  tower.position = center.clone();
  tower.position.y = height / 2;
  tower.material = cityBuildingMat;
  tower.checkCollisions = true;
  tower.receiveShadows = true;
  shadowGenerator.addShadowCaster(tower);

  const cap = BABYLON.MeshBuilder.CreateCylinder(
    name + "_cap",
    { diameterTop: 0, diameterBottom: radius * 2.3, height: height * 0.3, tessellation: 6 },
    scene
  );
  cap.position = center.clone();
  cap.position.y = height + (height * 0.2);
  cap.material = cityRoofMat;
  cap.receiveShadows = true;
  shadowGenerator.addShadowCaster(cap);

  return tower;
}

function createCityGate(name, center, spanWidth, gateHeight, thickness) {
  const arch = BABYLON.MeshBuilder.CreateBox(
    name + "_arch",
    { width: spanWidth, depth: thickness * 1.2, height: gateHeight * 0.6 },
    scene
  );
  arch.position = center.clone();
  arch.position.y = gateHeight * 0.3;
  arch.material = cityBuildingMat;
  arch.checkCollisions = true;
  arch.receiveShadows = true;
  shadowGenerator.addShadowCaster(arch);

  const sideOffset = (spanWidth / 2) - thickness * 1.6;
  createCityTower(
    name + "_left",
    new BABYLON.Vector3(center.x - sideOffset, 0, center.z - thickness * 0.6),
    thickness * 1.6,
    gateHeight * 1.4
  );
  createCityTower(
    name + "_right",
    new BABYLON.Vector3(center.x + sideOffset, 0, center.z - thickness * 0.6),
    thickness * 1.6,
    gateHeight * 1.4
  );
}

function createMarketStall(name, center, width, depth) {
  const table = BABYLON.MeshBuilder.CreateBox(
    name + "_table",
    { width, depth, height: 0.4 },
    scene
  );
  table.position = center.clone();
  table.position.y = 1;
  table.material = cityAccentMat;
  table.receiveShadows = true;
  shadowGenerator.addShadowCaster(table);

  const canopy = BABYLON.MeshBuilder.CreateBox(
    name + "_canopy",
    { width: width * 1.05, depth: depth * 1.05, height: 0.25 },
    scene
  );
  canopy.position = center.clone();
  canopy.position.y = 2.2;
  canopy.material = cityBannerMat;
  canopy.receiveShadows = true;
  shadowGenerator.addShadowCaster(canopy);
}

function hosgSpawnNpc(name, position, def) {
  if (def) {
    hosgRegisterNpc(name, def);
  } else if (!hosgNpcDefinitions[name]) {
    hosgRegisterNpc(name, {});
  }
  const npc = createNpc(name, position);
  npc.metadata = npc.metadata || {};
  npc.metadata.npcName = name;
  return npc;
}

function buildStartingCity() {
  // Inside-wall house ring around the central plaza
  const houseW = 8;
  const houseD = 6;
  const houseH = 4.2;

  // North row of houses overlooking the plaza
  for (let i = -1; i <= 1; i++) {
    const cx = i * (houseW + 1.5);
    const cz = 30 + 16; // just inside the north wall at z ~ 46
    createCityHouse("northHouse_" + i, new BABYLON.Vector3(cx, 0, cz), houseW, houseD, houseH, 2);
  }

  // South row facing the approach road
  for (let i = -1; i <= 1; i++) {
    const cx = i * (houseW + 1.5);
    const cz = 30 - 16; // inside south wall at z ~ 14
    createCityHouse("southHouse_" + i, new BABYLON.Vector3(cx, 0, cz), houseW, houseD, houseH * 0.9, 1);
  }

  // East and west sides of the plaza
  createCityHouse("eastHouse_1", new BABYLON.Vector3(30 - 5, 0, 30 + 8), houseW, houseD, houseH, 2);
  createCityHouse("eastHouse_2", new BABYLON.Vector3(30 - 5, 0, 30 - 8), houseW, houseD, houseH, 2);
  createCityHouse("westHouse_1", new BABYLON.Vector3(-30 + 5, 0, 30 + 8), houseW, houseD, houseH, 2);
  createCityHouse("westHouse_2", new BABYLON.Vector3(-30 + 5, 0, 30 - 8), houseW, houseD, houseH, 2);

  // A grand hall on the northern interior wall
  createCityHouse(
    "grandHall",
    new BABYLON.Vector3(0, 0, 30 + 18),
    houseW * 2.4,
    houseD * 1.6,
    houseH * 1.6,
    3
  );

  // A mage tower watching the river to the west
  createCityTower("mageTower", new BABYLON.Vector3(-32, 0, 18), 3.2, 18);

  // City gate aligned with the stone path at the south wall
  createCityGate("southGate", new BABYLON.Vector3(0, 0, 30 - 20), 22, 10, 2.4);

  // Market stalls along the north edge of the plaza
  createMarketStall("market_weapons", new BABYLON.Vector3(-8, 0, 30 + 10), 3.4, 2.4);
  createMarketStall("market_armor", new BABYLON.Vector3(0, 0, 30 + 10), 3.4, 2.4);
  createMarketStall("market_food", new BABYLON.Vector3(8, 0, 30 + 10), 3.4, 2.4);

  // Populate core NPCs for the starting city
  hosgSpawnNpc(
    "Captain Roderic",
    new BABYLON.Vector3(0, 1.5, 12),
    {
      role: "Gate Captain",
      kind: "guard",
      lines: [
        "Welcome to Shady Grove Landing. Keep your blade sharp and your wits sharper.",
        "No monsters past the wall on my watch.",
        "If you're looking for work, check the notice board in the plaza."
      ]
    }
  );

  hosgSpawnNpc(
    "Town Crier Ellyn",
    new BABYLON.Vector3(-2, 1.5, 30),
    {
      role: "Town Crier",
      kind: "herald",
      lines: [
        "Hear ye! Hear ye! New adventurers are arriving from every corner of Shady Grove.",
        "Quests and bounties will be posted soon. Keep an eye on the plaza!",
        "Glory and riches await those brave enough to step beyond the walls."
      ]
    }
  );

  hosgSpawnNpc(
    "Innkeeper Rhea",
    new BABYLON.Vector3(10, 1.5, 40),
    {
      role: "Innkeeper",
      kind: "merchant",
      lines: [
        "Rooms are full, but I've always got a warm stew for a hungry hero.",
        "Come back once the coin starts flowing and I'll have a proper tavern menu for you.",
        "Rest your feet at the Golden Grove when the road gets rough."
      ]
    }
  );

  hosgSpawnNpc(
    "Smith Torvald",
    new BABYLON.Vector3(18, 1.5, 28),
    {
      role: "Blacksmith",
      kind: "merchant",
      lines: [
        "Blades, bucklers, and bad ideas. I can help with two of those.",
        "I'll be reforging gear soon as the forges are hot and the gold is right.",
        "Steel remembers the hand that swings it. Swing true."
      ]
    }
  );

  hosgSpawnNpc(
    "Armorer Brinna",
    new BABYLON.Vector3(18, 1.5, 32),
    {
      role: "Armorer",
      kind: "merchant",
      lines: [
        "Armor's no good if you can't move in it. I build for fighters, not statues.",
        "I'll fit you for proper plate once you've proven you can survive leather.",
        "A dented breastplate is just a story with sharp edges."
      ]
    }
  );

  hosgSpawnNpc(
    "Magister Selian",
    new BABYLON.Vector3(-18, 1.5, 32),
    {
      role: "Arcane Instructor",
      kind: "trainer",
      lines: [
        "Magic is a pact, not a toy. Break it, and it will break you.",
        "I'll teach you to bend the elements once you've shown discipline.",
        "The veil beyond Shady Grove is thin. Best you learn to respect it."
      ]
    }
  );

  hosgSpawnNpc(
    "Guild Registrar Mira",
    new BABYLON.Vector3(0, 1.5, 42),
    {
      role: "Guild Registrar",
      kind: "guild",
      lines: [
        "One day, banners from a hundred guilds will hang over this plaza.",
        "I can see it now: your name etched on the rolls of legend.",
        "Bring friends, form a company, and I'll see it recognized."
      ]
    }
  );

  hosgSpawnNpc(
    "Mennonite Merchant",
    new BABYLON.Vector3(4, 1.5, 34),
    {
      role: "Traveling Merchant",
      kind: "merchant",
      lines: [
        "Fresh bread and shiny swords! Trading coming soon.",
        "I've got wares from every corner of Shady Grove—once the market opens.",
        "Coins first, stories later. That's my way of doing business."
      ]
    }
  );

  hosgSpawnNpc(
    "Village Guard Tomas",
    new BABYLON.Vector3(-6, 1.5, 26),
    {
      role: "City Guard",
      kind: "guard",
      lines: [
        "Stay out of trouble and we won't have a problem.",
        "The walls are sturdy, but it's the people inside that matter.",
        "If you see anything strange outside the gates, report to Captain Roderic."
      ]
    }
  );
}

// ----- HERO: new procedural humanoid with smooth walk -----
        let heroBody = BABYLON.MeshBuilder.CreateCapsule(
          "heroBody",
          {
            height: 2.8,
            radius: 0.6,
            tessellation: 10,
            subdivisions: 2
          },
          scene
        );
        // Place hero from saved state
        heroBody.position = new BABYLON.Vector3(
          playerState.position.x,
          playerState.position.y,
          playerState.position.z
        );
        heroBody.rotation.y = playerState.rotationY || 0;

        heroBody.ellipsoid = new BABYLON.Vector3(0.8, 1.4, 0.8);
        heroBody.ellipsoidOffset = new BABYLON.Vector3(0, 1.4, 0);
        heroBody.checkCollisions = true;
        heroBody.applyGravity = true;
        heroBody.visibility = 0.0; // invisible collider
        scene.heroBody = heroBody;

        const heroSkinMat = new BABYLON.StandardMaterial("heroSkinMat", scene);
        const heroClothMat = new BABYLON.StandardMaterial("heroClothMat", scene);
        const heroPantsMat = new BABYLON.StandardMaterial("heroPantsMat", scene);
        const heroBootMat = new BABYLON.StandardMaterial("heroBootMat", scene);

        applyAppearanceToMaterials(scene, {
          skin: heroSkinMat,
          tunic: heroClothMat,
          pants: heroPantsMat,
          boots: heroBootMat
        });

        heroSkinMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        const heroVisualRoot = new BABYLON.TransformNode("heroVisualRoot", scene);
        heroVisualRoot.parent = heroBody;
        heroVisualRoot.position = new BABYLON.Vector3(0, -0.4, 0);

        const heroRig = {
          root: heroVisualRoot,
          torso: null,
          head: null,
          shoulders: null,
          hips: null,
          leftArmJoint: null,
          rightArmJoint: null,
          leftLegJoint: null,
          rightLegJoint: null
        };

        // Torso
        const torso = BABYLON.MeshBuilder.CreateBox(
          "heroTorso",
          { width: 1.1, height: 2, depth: 0.7 },
          scene
        );
        torso.parent = heroVisualRoot;
        torso.position = new BABYLON.Vector3(0, 1.6, 0);
        torso.material = heroClothMat;
        heroRig.torso = torso;

        // Head
        const head = BABYLON.MeshBuilder.CreateSphere(
          "heroHead",
          { diameter: 0.9, segments: 8 },
          scene
        );
        head.parent = torso;
        head.position = new BABYLON.Vector3(0, 1.4, 0);
        head.material = heroSkinMat;
        heroRig.head = head;

        // Hips
        const hips = new BABYLON.TransformNode("heroHips", scene);
        hips.parent = heroVisualRoot;
        hips.position = new BABYLON.Vector3(0, 0.8, 0);
        heroRig.hips = hips;

        // Legs
        function createLeg(name, xSign) {
          const joint = new BABYLON.TransformNode(name + "Joint", scene);
          joint.parent = hips;
          joint.position = new BABYLON.Vector3(0.35 * xSign, 0, 0);

          const upper = BABYLON.MeshBuilder.CreateBox(
            name + "Upper",
            { width: 0.4, height: 1.7, depth: 0.4 },
            scene
          );
          upper.parent = joint;
          upper.position = new BABYLON.Vector3(0, -0.85, 0);
          upper.material = heroPantsMat;

          const boot = BABYLON.MeshBuilder.CreateBox(
            name + "Boot",
            { width: 0.5, height: 0.4, depth: 0.7 },
            scene
          );
          boot.parent = joint;
          boot.position = new BABYLON.Vector3(0, -1.7, 0.12);
          boot.material = heroBootMat;

          shadowGenerator.addShadowCaster(upper);
          shadowGenerator.addShadowCaster(boot);

          return joint;
        }

        heroRig.leftLegJoint = createLeg("heroLeftLeg", -1);
        heroRig.rightLegJoint = createLeg("heroRightLeg", 1);

        // Shoulders
        const shoulders = new BABYLON.TransformNode("heroShoulders", scene);
        shoulders.parent = torso;
        shoulders.position = new BABYLON.Vector3(0, 1.1, 0);
        heroRig.shoulders = shoulders;

        // Arms
        function createArm(name, xSign) {
          const joint = new BABYLON.TransformNode(name + "Joint", scene);
          joint.parent = shoulders;
          joint.position = new BABYLON.Vector3(0.75 * xSign, 0.1, 0);

          const upper = BABYLON.MeshBuilder.CreateBox(
            name + "Upper",
            { width: 0.35, height: 1.4, depth: 0.35 },
            scene
          );
          upper.parent = joint;
          upper.position = new BABYLON.Vector3(0, -0.7, 0);
          upper.material = heroClothMat;

          const hand = BABYLON.MeshBuilder.CreateBox(
            name + "Hand",
            { width: 0.3, height: 0.4, depth: 0.3 },
            scene
          );
          hand.parent = joint;
          hand.position = new BABYLON.Vector3(0, -1.25, 0);
          hand.material = heroSkinMat;

          shadowGenerator.addShadowCaster(upper);
          shadowGenerator.addShadowCaster(hand);

          return joint;
        }

        heroRig.leftArmJoint = createArm("heroLeftArm", -1);
        heroRig.rightArmJoint = createArm("heroRightArm", 1);

        shadowGenerator.addShadowCaster(torso);
        shadowGenerator.addShadowCaster(head);

        camera.target = heroBody.position.add(new BABYLON.Vector3(0, 2, 0));
        const hudHeroName = document.getElementById("hud-hero-name");
        if (hudHeroName && playerState && playerState.name) {
          hudHeroName.textContent = playerState.name + " of Shady Grove";
        }


        // Simple NPCs (boxes with nameplates)
        const npcMat = new BABYLON.StandardMaterial("npcMat", scene);
        npcMat.diffuseColor = new BABYLON.Color3(0.4, 0.7, 1.0);
        npcMat.emissiveColor = new BABYLON.Color3(0.03, 0.05, 0.09);

        function createNpc(name, position) {
          const npc = BABYLON.MeshBuilder.CreateBox(
            name,
            { width: 1.6, height: 3, depth: 1.2 },
            scene
          );
          npc.position = position.clone();
          npc.material = npcMat;
          npc.checkCollisions = true;
          npc.isPickable = true;
          shadowGenerator.addShadowCaster(npc);

          const plane = BABYLON.MeshBuilder.CreatePlane(
            name + "_nameplate",
            { width: 3, height: 0.6 },
            scene
          );
          plane.parent = npc;
          plane.position = new BABYLON.Vector3(0, 2.2, 0);
          plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

          const dynamicTex = new BABYLON.DynamicTexture(
            name + "_dt",
            { width: 256, height: 64 },
            scene,
            false
          );
          dynamicTex.hasAlpha = true;
          dynamicTex.drawText(
            name,
            null,
            42,
            "20px Segoe UI",
            "#ffffff",
            "transparent",
            true
          );

          const planeMat = new BABYLON.StandardMaterial(name + "_nameMat", scene);
          planeMat.diffuseTexture = dynamicTex;
          planeMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
          planeMat.backFaceCulling = false;
          plane.material = planeMat;

          return npc;
        }

        // NPCs are now spawned as part of the Shady Grove Landing buildStartingCity() helper.
        buildStartingCity();

        // -------- Input systems --------
        const inputMap = {};
        window.addEventListener("keydown", function (ev) {
          if (!ev || typeof ev.key !== "string") return;
          const key = ev.key.toLowerCase();
          inputMap[key] = true;
        });
        window.addEventListener("keyup", function (ev) {
          if (!ev || typeof ev.key !== "string") return;
          const key = ev.key.toLowerCase();
          inputMap[key] = false;
        });
        const mobileControls = document.getElementById("mobile-controls");
        const joystickBase = document.getElementById("joystick-base");
        const joystickThumb = document.getElementById("joystick-thumb");
        const btnJump = document.getElementById("btn-jump");
        const btnRun = document.getElementById("btn-run");

        const joystick = { x: 0, y: 0, active: false };
        let mobileRunHeld = false;
        let mobileJumpQueued = false;

        if (isMobile && mobileControls && joystickBase && joystickThumb && btnJump && btnRun) {
          mobileControls.style.display = "flex";

          let activeTouchId = null;
          const maxRadius = 60;

          function resetJoystick() {
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            activeTouchId = null;
            joystickThumb.style.transform = "translate(-50%, -50%)";
          }

          function updateJoystickFromTouch(touch) {
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            let clampedDx = dx;
            let clampedDy = dy;

            if (distance > maxRadius) {
              const ratio = maxRadius / distance;
              clampedDx *= ratio;
              clampedDy *= ratio;
            }

            joystickThumb.style.transform = "translate(" + clampedDx + "px, " + clampedDy + "px)";
            joystick.x = clampedDx / maxRadius;
            joystick.y = clampedDy / maxRadius;
            joystick.active = true;
          }

          joystickBase.addEventListener("touchstart", function (e) {
            e.preventDefault();
            const t = e.changedTouches[0];
            activeTouchId = t.identifier;
            updateJoystickFromTouch(t);
          }, { passive: false });

          joystickBase.addEventListener("touchmove", function (e) {
            e.preventDefault();
            if (activeTouchId === null) return;
            for (let i = 0; i < e.changedTouches.length; i++) {
              const t = e.changedTouches[i];
              if (t.identifier === activeTouchId) {
                updateJoystickFromTouch(t);
                break;
              }
            }
          }, { passive: false });

          joystickBase.addEventListener("touchend", function (e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
              const t = e.changedTouches[i];
              if (t.identifier === activeTouchId) {
                resetJoystick();
                break;
              }
            }
          }, { passive: false });

          joystickBase.addEventListener("touchcancel", function (e) {
            e.preventDefault();
            resetJoystick();
          }, { passive: false });

          btnJump.addEventListener("touchstart", function (e) {
            e.preventDefault();
            mobileJumpQueued = true;
          }, { passive: false });

          btnRun.addEventListener("touchstart", function (e) {
            e.preventDefault();
            mobileRunHeld = true;
          }, { passive: false });

          btnRun.addEventListener("touchend", function (e) {
            e.preventDefault();
            mobileRunHeld = false;
          }, { passive: false });

          btnRun.addEventListener("touchcancel", function (e) {
            e.preventDefault();
            mobileRunHeld = false;
          }, { passive: false });
        }

        const gamepadState = {
          hasPad: false,
          moveX: 0,
          moveY: 0,
          lookX: 0,
          lookY: 0,
          run: false,
          jump: false,
          lastJump: false
        };

        function updateGamepadState() {
          const getGamepads = navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads;
          if (!getGamepads) {
            gamepadState.hasPad = false;
            return;
          }
          const pads = getGamepads.call(navigator);
          let pad = null;
          for (let i = 0; i < pads.length; i++) {
            if (pads[i]) { pad = pads[i]; break; }
          }
          if (!pad) {
            gamepadState.hasPad = false;
            gamepadState.moveX = gamepadState.moveY = gamepadState.lookX = gamepadState.lookY = 0;
            gamepadState.run = gamepadState.jump = false;
            return;
          }
          gamepadState.hasPad = true;
          const axes = pad.axes || [];
          const buttons = pad.buttons || [];
          const dead = 0.2;
          function d(v) { return Math.abs(v) < dead ? 0 : v; }
          const lx = d(axes[0] || 0);
          const ly = d(axes[1] || 0);
          const rx = d(axes[2] || 0);
          const ry = d(axes[3] || 0);
          gamepadState.moveX = lx;
          gamepadState.moveY = ly;
          gamepadState.lookX = rx;
          gamepadState.lookY = ry;
          const jumpNow = buttons[0] && buttons[0].pressed;
          gamepadState.run = (buttons[1] && buttons[1].pressed) || (buttons[4] && buttons[4].pressed) || (buttons[5] && buttons[5].pressed);
          gamepadState.jump = !gamepadState.lastJump && !!jumpNow;
          gamepadState.lastJump = !!jumpNow;
        }

        function wrapAngle(a) {
          while (a > Math.PI) a -= Math.PI * 2;
          while (a < -Math.PI) a += Math.PI * 2;
          return a;
        }

        // HUD state
        let hudTime = 0;
        const hpFill = document.getElementById("hp-fill");
        const mpFill = document.getElementById("mp-fill");
        const hpLabel = document.getElementById("hp-label");
        const mpLabel = document.getElementById("mp-label");
        const xpFill = document.getElementById("xp-fill");
        const xpLabel = document.getElementById("xp-label");
        const levelLabel = document.getElementById("level-label");

        function updateHud(time) {
          // Clamp HP/MP into valid ranges; game logic should update hp/mp/xp/level
          if (hp > maxHp) hp = maxHp;
          if (hp < 0) hp = 0;
          if (mp > maxMp) mp = maxMp;
          if (mp < 0) mp = 0;
          hpFill.style.width = (hp / maxHp * 100) + "%";
          mpFill.style.width = (mp / maxMp * 100) + "%";
          xpFill.style.width = Math.min(100, xp) + "%";
          hpLabel.textContent = Math.round(hp) + " / " + maxHp;
          mpLabel.textContent = Math.round(mp) + " / " + maxMp;
          xpLabel.textContent = Math.round(xp) + "%";
          levelLabel.textContent = level;
        }

        // Movement/animation state
        const baseSpeed = 0.16;
        const runMultiplier = 1.8;
        const rotationLerp = 0.18;
        let verticalVelocity = 0;
        const jumpStrength = 0.22;
        let isGrounded = false;

        let walkCycleTime = 0;
        let autosaveTimer = 0;
        let netSendTimer = 0;

        scene.onBeforeRenderObservable.add(function () {
          const deltaTime = scene.getEngine().getDeltaTime();
          const dt = deltaTime / (1000 / 60);
          const dtSec = deltaTime / 1000;

          hudTime += dtSec;
          updateHud(hudTime);
          updateGamepadState();

          autosaveTimer += dtSec;
          netSendTimer += dtSec;

          let heroSpeed = baseSpeed;
          if (inputMap["shift"] || (gamepadState.hasPad && gamepadState.run) || mobileRunHeld) {
            heroSpeed *= runMultiplier;
          }

          let moveX = 0;
          let moveZ = 0;

          if (inputMap["w"]) moveZ += 1;
          if (inputMap["s"]) moveZ -= 1;
          if (inputMap["d"]) moveX += 1;
          if (inputMap["a"]) moveX -= 1;

          if (joystick.active) {
            moveZ += -joystick.y;
            moveX += joystick.x;
          }

          if (gamepadState.hasPad) {
            moveZ += -gamepadState.moveY;
            moveX += gamepadState.moveX;
          }

          const moveMagnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
          let isMoving = moveMagnitude > 0.05;

          // Jump
          const jumpRequested = (inputMap[" "] || mobileJumpQueued || (gamepadState.hasPad && gamepadState.jump));
          if (jumpRequested && isGrounded) {
            verticalVelocity = jumpStrength;
            isGrounded = false;
          }
          mobileJumpQueued = false;

          verticalVelocity += scene.gravity.y * dtSec;
          let nextPos = heroBody.position.clone();
          nextPos.y += verticalVelocity * dt;

          if (nextPos.y < 1.5) {
            nextPos.y = 1.5;
            verticalVelocity = 0;
            isGrounded = true;
          }

          let moveVecWorld = new BABYLON.Vector3(0, 0, 0);
          if (isMoving) {
            const normX = moveX / moveMagnitude;
            const normZ = moveZ / moveMagnitude;

            let forwardDir = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
            forwardDir.y = 0;
            forwardDir.normalize();

            let rightDir = camera.getDirection(new BABYLON.Vector3(1, 0, 0));
            rightDir.y = 0;
            rightDir.normalize();

            moveVecWorld = forwardDir.scale(normZ).add(rightDir.scale(normX));
            moveVecWorld.normalize();

            const desiredY = Math.atan2(moveVecWorld.x, moveVecWorld.z);
            const angleDiff = wrapAngle(desiredY - heroBody.rotation.y);
            heroBody.rotation.y += angleDiff * rotationLerp * dt;
          }

          if (isMoving) {
            const displacement = moveVecWorld.scale(heroSpeed * dt);
            nextPos.addInPlace(displacement);
          }

          heroBody.moveWithCollisions(nextPos.subtract(heroBody.position));

          // Procedural walk animation for hero rig
          if (heroRig.root) {
            if (isMoving) {
              walkCycleTime += dtSec * (heroSpeed / baseSpeed) * 4.2;
              const phase = walkCycleTime * Math.PI * 2;
              const swing = Math.sin(phase);
              const swingOpp = Math.sin(phase + Math.PI);
              const legSwing = 0.7;
              const armSwing = 0.8;

              heroRig.leftLegJoint.rotation.x = swing * legSwing;
              heroRig.rightLegJoint.rotation.x = swingOpp * legSwing;
              heroRig.leftArmJoint.rotation.x = swingOpp * armSwing * 0.6;
              heroRig.rightArmJoint.rotation.x = swing * armSwing * 0.6;

              const bob = Math.abs(Math.sin(phase)) * 0.06;
              heroRig.torso.position.y = 1.6 + bob;
            } else {
              // Relax to idle pose: arms at sides, legs straight, subtle breathing
              const relaxFactor = 1 - Math.pow(0.0001, dtSec); // smooth damping

              function dampJoint(joint) {
                joint.rotation.x -= joint.rotation.x * relaxFactor;
                joint.rotation.z -= joint.rotation.z * relaxFactor;
              }

              dampJoint(heroRig.leftLegJoint);
              dampJoint(heroRig.rightLegJoint);
              dampJoint(heroRig.leftArmJoint);
              dampJoint(heroRig.rightArmJoint);

              const baseTorsoY = 1.6;
              heroRig.torso.position.y += (baseTorsoY - heroRig.torso.position.y) * relaxFactor;

              walkCycleTime += dtSec * 0.5;
              const breath = Math.sin(walkCycleTime * Math.PI * 2) * 0.01;
              heroRig.torso.position.y = baseTorsoY + breath;
            }
          }

          camera.target = heroBody.position.add(new BABYLON.Vector3(0, 2, 0));

          if (gamepadState.hasPad) {
            const lookSpeed = 0.04;
            camera.alpha -= gamepadState.lookX * lookSpeed * dt;
            camera.beta -= gamepadState.lookY * lookSpeed * dt;
            const lowerBetaLimit = 0.3;
            const upperBetaLimit = Math.PI / 2;
            if (camera.beta < lowerBetaLimit) camera.beta = lowerBetaLimit;
            if (camera.beta > upperBetaLimit) camera.beta = upperBetaLimit;
          }

          // Autosave player state roughly twice per second (online-ready structure)
          if (autosaveTimer >= 0.5) {
            autosaveTimer = 0;
            savePlayerStateRuntime(
              heroBody,
              hp, maxHp,
              mp, maxMp,
              xp, level
            );
          }

          // Send multiplayer position/stats updates ~10x per second
          if (typeof mpSendLocalState === "function" && netSendTimer >= 0.1) {
            netSendTimer = 0;
            mpSendLocalState();
          }
        });

        scene.onPointerObservable.add(function (pointerInfo) {
  if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK) {
    const pick = pointerInfo.pickInfo;
    if (pick && pick.hit && pick.pickedMesh) {
      const mesh = pick.pickedMesh;
      const npcName =
        (mesh.metadata && mesh.metadata.npcName) ||
        (mesh.parent && mesh.parent.metadata && mesh.parent.metadata.npcName) ||
        mesh.name;
      const def = hosgNpcDefinitions[npcName];
      if (def) {
        const lines = (def.lines && def.lines.length)
          ? def.lines
          : ["Hello, adventurer."];
        const line = lines[Math.floor(Math.random() * lines.length)];
        const label = def.role ? def.name + " (" + def.role + ")" : def.name;
        appendChat(label + ": " + line);
      }
    }
  }
});


window.addEventListener("keydown", function (evt) {
  const chatInput = document.getElementById("chat-input");
  if (chatInput && chatInput === document.activeElement) return;
  if (evt.key === "e" || evt.key === "E") {
    hosgInteractWithNearestNpc();
  }
});
return scene;
      };

      const scene = createScene();

      setupCharacterCreationUI();
      setupAccountAndCharacterFlows();

// Hook multiplayer client (requires external Node.js WebSocket server)
// NOTE: we now connect only after the player actually enters the world,
// so that simply opening the page on another device/tab doesn't kick
// existing sessions offline.
let mpSendLocalState = null;
mpUpdateStatusLabel();

function hosgConnectMultiplayerIfNeeded() {
  if (typeof mpSendLocalState === "function") {
    return;
  }
  if (!scene.heroBody || !scene.shadowGenerator) {
    return;
  }
  mpSendLocalState = setupMultiplayer(
    scene,
    scene.heroBody,
    scene.shadowGenerator,
    function getRuntimeStats() {
      return {
        position: {
          x: scene.heroBody.position.x,
          y: scene.heroBody.position.y,
          z: scene.heroBody.position.z
        },
        rotationY: scene.heroBody.rotation.y,
        hp,
        maxHp,
        mp,
        maxMp,
        xp,
        level
      };
    }
  );
}

// Expose helper so the character creation flow can connect when "Start" succeeds
window.hosgConnectMultiplayerIfNeeded = hosgConnectMultiplayerIfNeeded;

      engine.runRenderLoop(function () {
        scene.render();
      });

      window.addEventListener("resize", function () {
        engine.resize();
      });
    })();
  </script>
</body>
</html>
diff --git a/index.html b/index.html
index bc9a0f19f344dfcef91ce5cc7227f13e0c0baf36..fef43c5b5c089f797cf57d69ebbdfc3ca8db0309 100644
--- a/index.html
+++ b/index.html
@@ -775,51 +775,51 @@
       padding: 4px 10px;
       font-size: 11px;
       color: #cfd8ff;
       pointer-events: auto;
     }
 
     #mp-status-text.online {
       color: #6bff7b;
     }
 
     #mp-status-text.offline {
       color: #ff7070;
     }
 
     #helper-keys {
         display: none;
       }
     }
   </style>
   <script src="https://cdn.babylonjs.com/babylon.js"></script>
 
   <script src="hosg_config.js"></script>
 <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
 </head>
 <body>
-  <!-- Game: Heroes of Shady Grove | Version: 1.0.31 -->
+  <!-- Game: Heroes of Shady Grove | Version: 1.0.32 -->
 
   <canvas id="renderCanvas"></canvas>
 
   <div id="hud">
     <div id="hud-left">
       <div class="hud-panel">
         <div class="hud-title"><span id="hud-hero-name">Felix of Shady Grove</span></div>
         <div class="bar">
           <div id="hp-fill" class="bar-fill"></div>
         </div>
         <div class="bar-label">
           <span>HP</span>
           <span id="hp-label">100 / 100</span>
         </div>
         <div class="bar">
           <div id="mp-fill" class="bar-fill"></div>
         </div>
         <div class="bar-label">
           <span>MP</span>
           <span id="mp-label">60 / 100</span>
         </div>
         <div id="xp-row">
           <span>Lv. <span id="level-label">1</span></span>
           <div id="xp-bar"><div id="xp-fill"></div></div>
           <span id="xp-label">25%</span>
@@ -909,50 +909,223 @@
   </div>
 
   <div id="mp-status">MP: <span id="mp-status-text">Offline</span></div>
 
   <div id="helper-keys">
     <div><strong>Controls</strong></div>
     <div>W / A / S / D – Move</div>
     <div>Right mouse drag – Orbit camera</div>
     <div>Shift / B – Run</div>
     <div>Space / A – Jump</div>
     <div>Scroll – Zoom camera</div>
   </div>
 
   <div id="mobile-controls">
     <div id="joystick-base">
       <div id="joystick-thumb"></div>
     </div>
     <div id="mobile-buttons">
       <button id="btn-jump">Jump</button>
       <button id="btn-run">Run</button>
     </div>
   </div>
 
   <script>
 
+// Lightweight grid-based zone streaming to start moving toward the large-world plan
+class ZoneStreamingManager {
+  constructor(scene, shadowGenerator) {
+    this.scene = scene;
+    this.shadowGenerator = shadowGenerator;
+    this.zones = [];
+    this.activeZoneIds = new Set();
+    this.lastCheck = 0;
+    this.checkIntervalMs = 500;
+  }
+
+  registerZone(def) {
+    this.zones.push({
+      id: def.id,
+      center: def.center,
+      halfSize: def.halfSize || 128,
+      buildContainer: def.buildContainer,
+      onEnter: def.onEnter,
+      onExit: def.onExit,
+      status: "unloaded",
+      container: null,
+      loadingPromise: null
+    });
+  }
+
+  async loadZone(zone) {
+    if (zone.status === "loaded") return;
+    if (zone.loadingPromise) {
+      await zone.loadingPromise;
+      return;
+    }
+    zone.loadingPromise = (async () => {
+      if (!zone.container) {
+        zone.container = await zone.buildContainer(this.scene, this.shadowGenerator);
+      }
+      zone.container.addAllToScene();
+      zone.status = "loaded";
+      this.activeZoneIds.add(zone.id);
+      if (typeof zone.onEnter === "function") zone.onEnter();
+    })();
+    await zone.loadingPromise;
+    zone.loadingPromise = null;
+  }
+
+  unloadZone(zone) {
+    if (zone.status !== "loaded" || !zone.container) return;
+    zone.container.removeAllFromScene();
+    zone.status = "unloaded";
+    this.activeZoneIds.delete(zone.id);
+    if (typeof zone.onExit === "function") zone.onExit();
+  }
+
+  async tick(playerPosition) {
+    const now = performance.now();
+    if (now - this.lastCheck < this.checkIntervalMs) return;
+    this.lastCheck = now;
+    if (!playerPosition) return;
+
+    const pendingLoads = [];
+    for (const zone of this.zones) {
+      const inZone = this.pointInside(playerPosition, zone.center, zone.halfSize);
+      if (inZone) {
+        if (zone.status !== "loaded") pendingLoads.push(this.loadZone(zone));
+      } else {
+        this.unloadZone(zone);
+      }
+    }
+    if (pendingLoads.length) await Promise.all(pendingLoads);
+  }
+
+  pointInside(point, center, halfSize) {
+    return (
+      point.x >= center.x - halfSize &&
+      point.x <= center.x + halfSize &&
+      point.z >= center.z - halfSize &&
+      point.z <= center.z + halfSize
+    );
+  }
+}
+
+function createForestZoneContainer(scene, shadowGenerator, id, center, size, seed) {
+  const container = new BABYLON.AssetContainer(scene);
+  const rng = mulberry32(seed || 1);
+  function track(mesh) {
+    container.meshes.push(mesh);
+    return mesh;
+  }
+
+  const ground = track(
+    BABYLON.MeshBuilder.CreateGround(
+      `ground_${id}`,
+      { width: size, height: size },
+      scene
+    )
+  );
+  ground.position = new BABYLON.Vector3(center.x, 0, center.z);
+  ground.material = new BABYLON.StandardMaterial(`groundMat_${id}`, scene);
+  ground.material.diffuseColor = new BABYLON.Color3(0.15, 0.32, 0.18);
+  ground.material.specularColor = new BABYLON.Color3(0.02, 0.02, 0.02);
+  ground.checkCollisions = true;
+
+  const hillCount = 6;
+  for (let i = 0; i < hillCount; i++) {
+    const offsetX = (rng() - 0.5) * (size * 0.6);
+    const offsetZ = (rng() - 0.5) * (size * 0.6);
+    const radius = 8 + rng() * 12;
+    const mound = track(
+      BABYLON.MeshBuilder.CreateCylinder(
+        `hill_${id}_${i}`,
+        { height: 6 + rng() * 6, diameterTop: radius * 0.6, diameterBottom: radius },
+        scene
+      )
+    );
+    mound.position = new BABYLON.Vector3(center.x + offsetX, 2.5, center.z + offsetZ);
+    mound.material = ground.material;
+    mound.checkCollisions = true;
+    mound.receiveShadows = true;
+  }
+
+  const foliageCount = 60;
+  const leafMat = new BABYLON.StandardMaterial(`leaf_${id}`, scene);
+  leafMat.diffuseColor = new BABYLON.Color3(0.18, 0.4, 0.2);
+  const trunkMat = new BABYLON.StandardMaterial(`trunk_${id}`, scene);
+  trunkMat.diffuseColor = new BABYLON.Color3(0.24, 0.18, 0.12);
+
+  for (let i = 0; i < foliageCount; i++) {
+    const angle = rng() * Math.PI * 2;
+    const radius = (size * 0.35) + rng() * (size * 0.15);
+    const posX = center.x + Math.cos(angle) * radius;
+    const posZ = center.z + Math.sin(angle) * radius;
+    const scale = 0.6 + rng() * 0.8;
+
+    const trunk = track(
+      BABYLON.MeshBuilder.CreateCylinder(
+        `tree_trunk_${id}_${i}`,
+        { height: 6 * scale, diameterTop: 0.7 * scale, diameterBottom: 1.1 * scale },
+        scene
+      )
+    );
+    trunk.position = new BABYLON.Vector3(posX, 3 * scale, posZ);
+    trunk.material = trunkMat;
+    trunk.checkCollisions = true;
+    trunk.receiveShadows = true;
+
+    const canopy = track(
+      BABYLON.MeshBuilder.CreateSphere(
+        `tree_canopy_${id}_${i}`,
+        { diameter: 6 * scale, segments: 6 },
+        scene
+      )
+    );
+    canopy.position = new BABYLON.Vector3(posX, 6.4 * scale, posZ);
+    canopy.material = leafMat;
+    canopy.checkCollisions = true;
+    canopy.receiveShadows = true;
+
+    shadowGenerator.addShadowCaster(trunk);
+    shadowGenerator.addShadowCaster(canopy);
+  }
+
+  container.removeAllFromScene();
+  return container;
+}
+
+function mulberry32(a) {
+  return function () {
+    a |= 0; a = a + 0x6D2B79F5 | 0;
+    let t = Math.imul(a ^ a >>> 15, 1 | a);
+    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
+    return ((t ^ t >>> 14) >>> 0) / 4294967296;
+  };
+}
+
 // NPC registry for the starting city and future zones
 
 function hosgInteractWithNearestNpc() {
   if (!scene || !scene.meshes || !heroBody) return;
   let best = null;
   let bestDistSq = Number.POSITIVE_INFINITY;
   const heroPos = heroBody.position;
   const maxDistSq = 7 * 7;
   for (const mesh of scene.meshes) {
     if (!mesh || !mesh.metadata || !mesh.metadata.npcName) continue;
     const dx = mesh.position.x - heroPos.x;
     const dz = mesh.position.z - heroPos.z;
     const distSq = dx * dx + dz * dz;
     if (distSq < maxDistSq && distSq < bestDistSq) {
       bestDistSq = distSq;
       best = mesh;
     }
   }
   if (!best) return;
   const npcName = best.metadata.npcName;
   const def = hosgNpcDefinitions[npcName];
   if (!def) return;
   const lines = (def.lines && def.lines.length)
     ? def.lines
     : ["Hello, adventurer."];
@@ -2151,123 +2324,205 @@ function setupMultiplayer(scene, heroBody, shadowGenerator, getRuntimeStats) {
               mpSocket.send(JSON.stringify(msg));
             } catch (e) {
               console.warn("Failed to send chat", e);
             }
           } else {
             appendChat("You: " + value);
           }
 
           input.value = "";
         }
 
         send.addEventListener("click", sendMessage);
         input.addEventListener("keydown", function (ev) {
           if (ev.key === "Enter") {
             sendMessage();
           }
         });
 
         appendChat("System: Type to chat. If connected to the multiplayer server, your messages will be sent to other players.");
       })();
 
       const createScene = function () {
         const scene = new BABYLON.Scene(engine);
         scene.gravity = new BABYLON.Vector3(0, -0.5, 0);
         scene.collisionsEnabled = true;
+        scene.clearColor = new BABYLON.Color3(0.015, 0.02, 0.035);
+        scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
+        scene.fogDensity = 0.0022;
+        scene.fogColor = new BABYLON.Color3(0.04, 0.07, 0.12);
 
         const envTex = new BABYLON.CubeTexture(
           "https://playground.babylonjs.com/textures/environment.env",
           scene
         );
         scene.environmentTexture = envTex;
         scene.createDefaultSkybox(envTex, true, 1000);
 
         const camera = new BABYLON.ArcRotateCamera(
           "camera",
           -Math.PI / 2,
           0.9,
           40,
           new BABYLON.Vector3(0, 3, 0),
           scene
         );
         camera.lowerRadiusLimit = 18;
         camera.upperRadiusLimit = 70;
         camera.wheelDeltaPercentage = 0.02;
         camera.panningSensibility = 0;
         camera.attachControl(canvas, true);
         camera.checkCollisions = false;
 
         const hemiLight = new BABYLON.HemisphericLight(
           "hemi",
           new BABYLON.Vector3(0, 1, 0),
           scene
         );
         hemiLight.intensity = 0.6;
 
+        const pipeline = new BABYLON.DefaultRenderingPipeline(
+          "hosgFx",
+          true,
+          scene,
+          [camera]
+        );
+        pipeline.imageProcessingEnabled = true;
+        pipeline.imageProcessing.toneMappingEnabled = true;
+        pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
+        pipeline.imageProcessing.exposure = 1.05;
+        pipeline.imageProcessing.contrast = 1.12;
+        pipeline.bloomEnabled = true;
+        pipeline.bloomThreshold = 0.62;
+        pipeline.bloomWeight = 0.34;
+        pipeline.bloomScale = 0.5;
+        pipeline.grainEnabled = true;
+        pipeline.grain.animated = true;
+        pipeline.grain.intensity = 8.5;
+
         const sun = new BABYLON.DirectionalLight(
           "sun",
           new BABYLON.Vector3(-0.5, -1, -0.3),
           scene
         );
         sun.position = new BABYLON.Vector3(60, 80, 60);
         sun.intensity = 1.1;
 
         const shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
         shadowGenerator.useBlurExponentialShadowMap = true;
         shadowGenerator.blurKernel = 16;
         scene.shadowGenerator = shadowGenerator;
 
+        function createFireflyField(name, center, radius, height, color) {
+          const fireflies = new BABYLON.ParticleSystem(name, 800, scene);
+          fireflies.particleTexture = new BABYLON.Texture(
+            "https://playground.babylonjs.com/textures/flare.png",
+            scene
+          );
+          fireflies.emitter = center;
+          fireflies.minEmitBox = new BABYLON.Vector3(-radius, 0, -radius);
+          fireflies.maxEmitBox = new BABYLON.Vector3(radius, height, radius);
+          fireflies.color1 = new BABYLON.Color4(color.r, color.g, color.b, 0.9);
+          fireflies.color2 = new BABYLON.Color4(color.r, color.g, color.b, 0.4);
+          fireflies.colorDead = new BABYLON.Color4(color.r, color.g, color.b, 0);
+          fireflies.minSize = 0.1;
+          fireflies.maxSize = 0.25;
+          fireflies.minLifeTime = 2.5;
+          fireflies.maxLifeTime = 4.5;
+          fireflies.emitRate = 240;
+          fireflies.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
+          fireflies.gravity = new BABYLON.Vector3(0, -0.05, 0);
+          fireflies.direction1 = new BABYLON.Vector3(-0.25, 0.6, -0.25);
+          fireflies.direction2 = new BABYLON.Vector3(0.25, 0.2, 0.25);
+          fireflies.minAngularSpeed = -0.5;
+          fireflies.maxAngularSpeed = 0.5;
+          fireflies.minEmitPower = 0.2;
+          fireflies.maxEmitPower = 0.6;
+          fireflies.updateSpeed = 0.008;
+          fireflies.start();
+          return fireflies;
+        }
+
+        function createMistPlume(name, center, radius) {
+          const mist = new BABYLON.ParticleSystem(name, 600, scene);
+          mist.particleTexture = new BABYLON.Texture(
+            "https://playground.babylonjs.com/textures/flare.png",
+            scene
+          );
+          mist.emitter = center;
+          mist.minEmitBox = new BABYLON.Vector3(-radius, 0, -radius);
+          mist.maxEmitBox = new BABYLON.Vector3(radius, 0.1, radius);
+          mist.color1 = new BABYLON.Color4(0.75, 0.86, 1, 0.35);
+          mist.color2 = new BABYLON.Color4(0.6, 0.78, 1, 0.18);
+          mist.colorDead = new BABYLON.Color4(0.6, 0.78, 1, 0.02);
+          mist.minSize = 1.4;
+          mist.maxSize = 2.6;
+          mist.minLifeTime = 2.5;
+          mist.maxLifeTime = 5.0;
+          mist.emitRate = 220;
+          mist.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;
+          mist.gravity = new BABYLON.Vector3(0, 0.04, 0);
+          mist.direction1 = new BABYLON.Vector3(-0.05, 0.4, -0.05);
+          mist.direction2 = new BABYLON.Vector3(0.05, 0.6, 0.05);
+          mist.minEmitPower = 0.08;
+          mist.maxEmitPower = 0.18;
+          mist.updateSpeed = 0.0075;
+          mist.start();
+          return mist;
+        }
+
         // World: ground, water, trees, simple town plaza
         const ground = BABYLON.MeshBuilder.CreateGround(
           "ground",
           { width: 220, height: 220, subdivisions: 80 },
           scene
         );
         ground.checkCollisions = true;
         const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
         groundMat.diffuseTexture = new BABYLON.Texture(
           "https://playground.babylonjs.com/textures/grass.jpg",
           scene
         );
         groundMat.diffuseTexture.uScale = 40;
         groundMat.diffuseTexture.vScale = 40;
         groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
         ground.material = groundMat;
         ground.receiveShadows = true;
 
         const water = BABYLON.MeshBuilder.CreateGround(
           "water",
           { width: 80, height: 80, subdivisions: 2 },
           scene
         );
         water.position = new BABYLON.Vector3(0, 0.02, -60);
         const waterMat = new BABYLON.StandardMaterial("waterMat", scene);
         waterMat.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.6);
         waterMat.alpha = 0.6;
         waterMat.specularColor = new BABYLON.Color3(0.6, 0.8, 1);
         waterMat.backFaceCulling = false;
         water.material = waterMat;
+        createMistPlume("lakeMist", new BABYLON.Vector3(0, 0.02, -60), 36);
 
         const stonePathMat = new BABYLON.StandardMaterial("stoneMat", scene);
         stonePathMat.diffuseTexture = new BABYLON.Texture(
           "https://playground.babylonjs.com/textures/rock.png",
           scene
         );
         stonePathMat.diffuseTexture.uScale = 4;
         stonePathMat.diffuseTexture.vScale = 4;
         stonePathMat.specularColor = new BABYLON.Color3(0.02, 0.02, 0.02);
 
         for (let i = -30; i <= 30; i += 5) {
           const stone = BABYLON.MeshBuilder.CreateBox(
             "pathStone",
             { width: 2.5, height: 0.4, depth: 2.5 },
             scene
           );
           stone.position = new BABYLON.Vector3(i, 0.2, 0);
           stone.material = stonePathMat;
           stone.checkCollisions = true;
           stone.receiveShadows = true;
         }
 
         const treeTrunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
         treeTrunkMat.diffuseTexture = new BABYLON.Texture(
           "https://playground.babylonjs.com/textures/wood.jpg",
@@ -2290,50 +2545,57 @@ function setupMultiplayer(scene, heroBody, shadowGenerator, getRuntimeStats) {
           trunk.checkCollisions = true;
           trunk.receiveShadows = true;
 
           const canopy = BABYLON.MeshBuilder.CreateSphere(
             "canopy",
             { diameter: 6 * scale, segments: 8 },
             scene
           );
           canopy.position = new BABYLON.Vector3(x, 6.5 * scale, z);
           canopy.material = treeLeafMat;
           canopy.checkCollisions = true;
           canopy.receiveShadows = true;
 
           shadowGenerator.addShadowCaster(trunk);
           shadowGenerator.addShadowCaster(canopy);
         }
 
         for (let i = 0; i < 80; i++) {
           const radius = 80 + Math.random() * 30;
           const angle = Math.random() * Math.PI * 2;
           const x = Math.cos(angle) * radius;
           const z = Math.sin(angle) * radius;
           const scale = 0.6 + Math.random() * 0.8;
           createTree(x, z, scale);
         }
+        createFireflyField(
+          "forestFireflies",
+          new BABYLON.Vector3(0, 2, 0),
+          95,
+          7,
+          new BABYLON.Color3(0.72, 0.98, 0.68)
+        );
 
         const townMat = new BABYLON.StandardMaterial("townMat", scene);
         townMat.diffuseTexture = new BABYLON.Texture(
           "https://playground.babylonjs.com/textures/floor.png",
           scene
         );
         townMat.diffuseTexture.uScale = 4;
         townMat.diffuseTexture.vScale = 4;
 
         const plaza = BABYLON.MeshBuilder.CreateBox(
           "plaza",
           { width: 40, depth: 40, height: 1 },
           scene
         );
         plaza.position = new BABYLON.Vector3(0, 0.5, 30);
         plaza.material = townMat;
         plaza.checkCollisions = true;
         plaza.receiveShadows = true;
 
         const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
         wallMat.diffuseTexture = new BABYLON.Texture(
           "https://playground.babylonjs.com/textures/floor.png",
           scene
         );
         wallMat.diffuseTexture.uScale = 2;
@@ -2362,68 +2624,84 @@ function setupMultiplayer(scene, heroBody, shadowGenerator, getRuntimeStats) {
         createWall(
           new BABYLON.Vector3(-half, 0, 30 - half),
           new BABYLON.Vector3(half, 0, 30 - half),
           height,
           thickness
         );
         createWall(
           new BABYLON.Vector3(-half, 0, 30 + half),
           new BABYLON.Vector3(half, 0, 30 + half),
           height,
           thickness
         );
         createWall(
           new BABYLON.Vector3(-half, 0, 30 - half),
           new BABYLON.Vector3(-half, 0, 30 + half),
           height,
           thickness
         );
         createWall(
           new BABYLON.Vector3(half, 0, 30 - half),
           new BABYLON.Vector3(half, 0, 30 + half),
           height,
           thickness
         );
 
-        
+        createFireflyField(
+          "plazaLanterns",
+          new BABYLON.Vector3(0, 2.4, 30),
+          22,
+          5,
+          new BABYLON.Color3(0.98, 0.83, 0.52)
+        );
+
+
 // ----- GRAND STARTING CITY: Shady Grove Landing -----
 const cityBuildingMat = new BABYLON.StandardMaterial("cityBuildingMat", scene);
 cityBuildingMat.diffuseColor = new BABYLON.Color3(0.78, 0.74, 0.65);
 cityBuildingMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
 
 const cityRoofMat = new BABYLON.StandardMaterial("cityRoofMat", scene);
 cityRoofMat.diffuseColor = new BABYLON.Color3(0.42, 0.18, 0.12);
 cityRoofMat.specularColor = new BABYLON.Color3(0.06, 0.06, 0.06);
 
 const cityAccentMat = new BABYLON.StandardMaterial("cityAccentMat", scene);
 cityAccentMat.diffuseColor = new BABYLON.Color3(0.86, 0.82, 0.72);
 cityAccentMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
 
 const cityBannerMat = new BABYLON.StandardMaterial("cityBannerMat", scene);
 cityBannerMat.diffuseColor = new BABYLON.Color3(0.18, 0.32, 0.68);
 cityBannerMat.emissiveColor = new BABYLON.Color3(0.02, 0.05, 0.15);
 
+const boulevardMat = new BABYLON.StandardMaterial("boulevardMat", scene);
+boulevardMat.diffuseColor = new BABYLON.Color3(0.28, 0.29, 0.32);
+boulevardMat.specularColor = new BABYLON.Color3(0.03, 0.03, 0.03);
+
+const plazaInlayMat = new BABYLON.StandardMaterial("plazaInlayMat", scene);
+plazaInlayMat.diffuseColor = new BABYLON.Color3(0.74, 0.72, 0.66);
+plazaInlayMat.specularColor = new BABYLON.Color3(0.06, 0.06, 0.06);
+
 function createCityHouse(name, center, width, depth, height, floors) {
   const base = BABYLON.MeshBuilder.CreateBox(
     name + "_base",
     { width, depth, height },
     scene
   );
   base.position = center.clone();
   base.position.y = height / 2;
   base.material = cityBuildingMat;
   base.checkCollisions = true;
   base.receiveShadows = true;
   shadowGenerator.addShadowCaster(base);
 
   const roof = BABYLON.MeshBuilder.CreateBox(
     name + "_roof",
     { width: width * 1.02, depth: depth * 1.02, height: height * 0.45 },
     scene
   );
   roof.position = center.clone();
   roof.position.y = height + (height * 0.25);
   roof.rotation.z = Math.PI / 18;
   roof.material = cityRoofMat;
   roof.checkCollisions = false;
   roof.receiveShadows = true;
   shadowGenerator.addShadowCaster(roof);
@@ -2574,50 +2852,245 @@ function buildStartingCity() {
   createCityHouse("eastHouse_2", new BABYLON.Vector3(30 - 5, 0, 30 - 8), houseW, houseD, houseH, 2);
   createCityHouse("westHouse_1", new BABYLON.Vector3(-30 + 5, 0, 30 + 8), houseW, houseD, houseH, 2);
   createCityHouse("westHouse_2", new BABYLON.Vector3(-30 + 5, 0, 30 - 8), houseW, houseD, houseH, 2);
 
   // A grand hall on the northern interior wall
   createCityHouse(
     "grandHall",
     new BABYLON.Vector3(0, 0, 30 + 18),
     houseW * 2.4,
     houseD * 1.6,
     houseH * 1.6,
     3
   );
 
   // A mage tower watching the river to the west
   createCityTower("mageTower", new BABYLON.Vector3(-32, 0, 18), 3.2, 18);
 
   // City gate aligned with the stone path at the south wall
   createCityGate("southGate", new BABYLON.Vector3(0, 0, 30 - 20), 22, 10, 2.4);
 
   // Market stalls along the north edge of the plaza
   createMarketStall("market_weapons", new BABYLON.Vector3(-8, 0, 30 + 10), 3.4, 2.4);
   createMarketStall("market_armor", new BABYLON.Vector3(0, 0, 30 + 10), 3.4, 2.4);
   createMarketStall("market_food", new BABYLON.Vector3(8, 0, 30 + 10), 3.4, 2.4);
 
+  function createRoadSegment(name, from, to, width, thickness = 0.35) {
+    const length = BABYLON.Vector3.Distance(from, to);
+    const road = BABYLON.MeshBuilder.CreateBox(
+      name,
+      { width: length, depth: width, height: thickness },
+      scene
+    );
+    road.position = from.add(to).scale(0.5);
+    road.position.y = thickness / 2;
+    const dir = to.subtract(from);
+    road.rotation.y = Math.atan2(dir.z, dir.x);
+    road.material = boulevardMat;
+    road.checkCollisions = true;
+    road.receiveShadows = true;
+    shadowGenerator.addShadowCaster(road);
+    return road;
+  }
+
+  function createStreetLamp(name, position) {
+    const pole = BABYLON.MeshBuilder.CreateCylinder(
+      name + "_pole",
+      { diameter: 0.25, height: 4 },
+      scene
+    );
+    pole.position = position.clone();
+    pole.position.y = 2;
+    pole.material = cityAccentMat;
+    pole.checkCollisions = true;
+    pole.receiveShadows = true;
+    shadowGenerator.addShadowCaster(pole);
+
+    const glow = BABYLON.MeshBuilder.CreateSphere(
+      name + "_glow",
+      { diameter: 0.6, segments: 8 },
+      scene
+    );
+    glow.position = position.clone();
+    glow.position.y = 4.5;
+    glow.material = cityBannerMat;
+    glow.material.emissiveColor = new BABYLON.Color3(0.65, 0.72, 0.88);
+    shadowGenerator.addShadowCaster(glow);
+  }
+
+  function layHouseRow(prefix, start, count, step, dims, floors = 2) {
+    for (let i = 0; i < count; i++) {
+      const offset = new BABYLON.Vector3(step.x * i, 0, step.z * i);
+      createCityHouse(
+        `${prefix}_${i}`,
+        start.add(offset),
+        dims.width,
+        dims.depth,
+        dims.height,
+        floors
+      );
+    }
+  }
+
+  // Grand perimeter walls around the expanded landing city
+  const outerHalf = 70;
+  const outerHeight = 12;
+  const outerThickness = 2.4;
+  createWall(
+    new BABYLON.Vector3(-outerHalf, 0, 30 - outerHalf - 10),
+    new BABYLON.Vector3(outerHalf, 0, 30 - outerHalf - 10),
+    outerHeight,
+    outerThickness
+  );
+  createWall(
+    new BABYLON.Vector3(-outerHalf, 0, 30 + outerHalf + 10),
+    new BABYLON.Vector3(outerHalf, 0, 30 + outerHalf + 10),
+    outerHeight,
+    outerThickness
+  );
+  createWall(
+    new BABYLON.Vector3(-outerHalf, 0, 30 - outerHalf - 10),
+    new BABYLON.Vector3(-outerHalf, 0, 30 + outerHalf + 10),
+    outerHeight,
+    outerThickness
+  );
+  createWall(
+    new BABYLON.Vector3(outerHalf, 0, 30 - outerHalf - 10),
+    new BABYLON.Vector3(outerHalf, 0, 30 + outerHalf + 10),
+    outerHeight,
+    outerThickness
+  );
+
+  createCityGate("outerSouthGate", new BABYLON.Vector3(0, 0, -50), 26, 14, 3);
+  createCityGate("outerNorthGate", new BABYLON.Vector3(0, 0, 100), 26, 14, 3);
+  createCityGate("outerEastGate", new BABYLON.Vector3(70, 0, 30), 20, 12, 2.6);
+  createCityGate("outerWestGate", new BABYLON.Vector3(-70, 0, 30), 20, 12, 2.6);
+
+  createCityTower("outerCornerNW", new BABYLON.Vector3(-outerHalf, 0, 30 + outerHalf + 10), 4, 20);
+  createCityTower("outerCornerNE", new BABYLON.Vector3(outerHalf, 0, 30 + outerHalf + 10), 4, 20);
+  createCityTower("outerCornerSW", new BABYLON.Vector3(-outerHalf, 0, 30 - outerHalf - 10), 4, 20);
+  createCityTower("outerCornerSE", new BABYLON.Vector3(outerHalf, 0, 30 - outerHalf - 10), 4, 20);
+
+  // City boulevards stitching the plaza to each gate
+  createRoadSegment("main_avenue", new BABYLON.Vector3(-60, 0, 30), new BABYLON.Vector3(60, 0, 30), 8);
+  createRoadSegment("south_approach", new BABYLON.Vector3(0, 0, -50), new BABYLON.Vector3(0, 0, 12), 9);
+  createRoadSegment("north_avenue", new BABYLON.Vector3(0, 0, 100), new BABYLON.Vector3(0, 0, 48), 9);
+  createRoadSegment("east_way", new BABYLON.Vector3(70, 0, 30), new BABYLON.Vector3(24, 0, 30), 7);
+  createRoadSegment("west_way", new BABYLON.Vector3(-70, 0, 30), new BABYLON.Vector3(-24, 0, 30), 7);
+
+  // Lamp posts lining the main square and arteries
+  const lampSpots = [
+    new BABYLON.Vector3(12, 0, 30),
+    new BABYLON.Vector3(-12, 0, 30),
+    new BABYLON.Vector3(0, 0, 14),
+    new BABYLON.Vector3(0, 0, 46),
+    new BABYLON.Vector3(24, 0, 30),
+    new BABYLON.Vector3(-24, 0, 30),
+    new BABYLON.Vector3(0, 0, 66),
+    new BABYLON.Vector3(0, 0, -18)
+  ];
+  lampSpots.forEach((pos, idx) => createStreetLamp("cityLamp_" + idx, pos));
+
+  // Residential belts along the east and west sides of the plaza boulevard
+  layHouseRow(
+    "eastRow_north",
+    new BABYLON.Vector3(32, 0, 64),
+    4,
+    new BABYLON.Vector3(0, 0, -12),
+    { width: 7.5, depth: 6, height: 4.4 },
+    3
+  );
+  layHouseRow(
+    "eastRow_south",
+    new BABYLON.Vector3(32, 0, 10),
+    4,
+    new BABYLON.Vector3(0, 0, -12),
+    { width: 7.5, depth: 6, height: 4.2 },
+    2
+  );
+  layHouseRow(
+    "westRow_north",
+    new BABYLON.Vector3(-32, 0, 64),
+    4,
+    new BABYLON.Vector3(0, 0, -12),
+    { width: 7.5, depth: 6, height: 4.4 },
+    3
+  );
+  layHouseRow(
+    "westRow_south",
+    new BABYLON.Vector3(-32, 0, 10),
+    4,
+    new BABYLON.Vector3(0, 0, -12),
+    { width: 7.5, depth: 6, height: 4.2 },
+    2
+  );
+
+  // Northern civic district: guild hall, archives, and lookout tower
+  createCityHouse("guildHall", new BABYLON.Vector3(-10, 0, 82), 16, 10, 7, 3);
+  createCityHouse("archives", new BABYLON.Vector3(14, 0, 84), 12, 9, 6.5, 2);
+  createCityTower("northWatch", new BABYLON.Vector3(0, 0, 92), 3.8, 18);
+
+  // Southern crafts district and barracks lining the approach road
+  createCityHouse("barracks", new BABYLON.Vector3(-14, 0, -18), 18, 9, 5, 2);
+  createCityHouse("workshopRow", new BABYLON.Vector3(16, 0, -16), 14, 8, 4.4, 2);
+  layHouseRow(
+    "crafts_lane",
+    new BABYLON.Vector3(-26, 0, -8),
+    3,
+    new BABYLON.Vector3(12, 0, 0),
+    { width: 6.5, depth: 5.2, height: 4 },
+    2
+  );
+
+  // Lakeside warehouses and docks hugging the river inlet
+  createCityHouse("warehouse_west", new BABYLON.Vector3(-22, 0, -44), 12, 9, 5, 2);
+  createCityHouse("warehouse_east", new BABYLON.Vector3(22, 0, -44), 12, 9, 5, 2);
+  createMarketStall("dock_cart_1", new BABYLON.Vector3(-8, 0, -52), 4, 3);
+  createMarketStall("dock_cart_2", new BABYLON.Vector3(8, 0, -52), 4, 3);
+
+  // Interior plaza upgrade: stone inlays and a central obelisk
+  const plazaInlay = BABYLON.MeshBuilder.CreateBox(
+    "plazaInlay",
+    { width: 24, depth: 24, height: 0.25 },
+    scene
+  );
+  plazaInlay.position = new BABYLON.Vector3(0, 0.38, 30);
+  plazaInlay.material = plazaInlayMat;
+  plazaInlay.checkCollisions = false;
+  plazaInlay.receiveShadows = true;
+  shadowGenerator.addShadowCaster(plazaInlay);
+
+  const obelisk = BABYLON.MeshBuilder.CreateCylinder(
+    "plazaObelisk",
+    { diameterTop: 0.8, diameterBottom: 1.8, height: 10, tessellation: 6 },
+    scene
+  );
+  obelisk.position = new BABYLON.Vector3(0, 5.5, 30);
+  obelisk.material = cityAccentMat;
+  obelisk.receiveShadows = true;
+  shadowGenerator.addShadowCaster(obelisk);
+
   // Populate core NPCs for the starting city
   hosgSpawnNpc(
     "Captain Roderic",
     new BABYLON.Vector3(0, 1.5, 12),
     {
       role: "Gate Captain",
       kind: "guard",
       lines: [
         "Welcome to Shady Grove Landing. Keep your blade sharp and your wits sharper.",
         "No monsters past the wall on my watch.",
         "If you're looking for work, check the notice board in the plaza."
       ]
     }
   );
 
   hosgSpawnNpc(
     "Town Crier Ellyn",
     new BABYLON.Vector3(-2, 1.5, 30),
     {
       role: "Town Crier",
       kind: "herald",
       lines: [
         "Hear ye! Hear ye! New adventurers are arriving from every corner of Shady Grove.",
         "Quests and bounties will be posted soon. Keep an eye on the plaza!",
         "Glory and riches await those brave enough to step beyond the walls."
@@ -2702,76 +3175,103 @@ function buildStartingCity() {
       role: "Traveling Merchant",
       kind: "merchant",
       lines: [
         "Fresh bread and shiny swords! Trading coming soon.",
         "I've got wares from every corner of Shady Grove—once the market opens.",
         "Coins first, stories later. That's my way of doing business."
       ]
     }
   );
 
   hosgSpawnNpc(
     "Village Guard Tomas",
     new BABYLON.Vector3(-6, 1.5, 26),
     {
       role: "City Guard",
       kind: "guard",
       lines: [
         "Stay out of trouble and we won't have a problem.",
         "The walls are sturdy, but it's the people inside that matter.",
         "If you see anything strange outside the gates, report to Captain Roderic."
       ]
     }
   );
 }
 
+        // Kick off the first streaming-ready expansion zones around the landing area
+        const zoneManager = new ZoneStreamingManager(scene, shadowGenerator);
+        const tileSize = 220;
+        const ring = [
+          { id: "north_forest", center: new BABYLON.Vector3(0, 0, tileSize * 1.2), seed: 11 },
+          { id: "south_forest", center: new BABYLON.Vector3(0, 0, -tileSize * 1.2), seed: 21 },
+          { id: "east_forest", center: new BABYLON.Vector3(tileSize * 1.2, 0, 0), seed: 33 },
+          { id: "west_forest", center: new BABYLON.Vector3(-tileSize * 1.2, 0, 0), seed: 44 },
+        ];
+
+        ring.forEach((entry) => {
+          zoneManager.registerZone({
+            id: entry.id,
+            center: entry.center,
+            halfSize: tileSize * 0.6,
+            buildContainer: (scene, shadowGenerator) => Promise.resolve(
+              createForestZoneContainer(scene, shadowGenerator, entry.id, entry.center, tileSize, entry.seed)
+            )
+          });
+        });
+
+        scene.zoneManager = zoneManager;
+
 // ----- HERO: new procedural humanoid with smooth walk -----
         let heroBody = BABYLON.MeshBuilder.CreateCapsule(
           "heroBody",
           {
             height: 2.8,
             radius: 0.6,
             tessellation: 10,
             subdivisions: 2
           },
           scene
         );
         // Place hero from saved state
         heroBody.position = new BABYLON.Vector3(
           playerState.position.x,
           playerState.position.y,
           playerState.position.z
         );
         heroBody.rotation.y = playerState.rotationY || 0;
 
         heroBody.ellipsoid = new BABYLON.Vector3(0.8, 1.4, 0.8);
         heroBody.ellipsoidOffset = new BABYLON.Vector3(0, 1.4, 0);
         heroBody.checkCollisions = true;
         heroBody.applyGravity = true;
         heroBody.visibility = 0.0; // invisible collider
         scene.heroBody = heroBody;
 
+        if (scene.zoneManager) {
+          scene.zoneManager.tick(heroBody.position);
+        }
+
         const heroSkinMat = new BABYLON.StandardMaterial("heroSkinMat", scene);
         const heroClothMat = new BABYLON.StandardMaterial("heroClothMat", scene);
         const heroPantsMat = new BABYLON.StandardMaterial("heroPantsMat", scene);
         const heroBootMat = new BABYLON.StandardMaterial("heroBootMat", scene);
 
         applyAppearanceToMaterials(scene, {
           skin: heroSkinMat,
           tunic: heroClothMat,
           pants: heroPantsMat,
           boots: heroBootMat
         });
 
         heroSkinMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
 
         const heroVisualRoot = new BABYLON.TransformNode("heroVisualRoot", scene);
         heroVisualRoot.parent = heroBody;
         heroVisualRoot.position = new BABYLON.Vector3(0, -0.4, 0);
 
         const heroRig = {
           root: heroVisualRoot,
           torso: null,
           head: null,
           shoulders: null,
           hips: null,
           leftArmJoint: null,
@@ -3360,35 +3860,38 @@ function hosgConnectMultiplayerIfNeeded() {
     scene.heroBody,
     scene.shadowGenerator,
     function getRuntimeStats() {
       return {
         position: {
           x: scene.heroBody.position.x,
           y: scene.heroBody.position.y,
           z: scene.heroBody.position.z
         },
         rotationY: scene.heroBody.rotation.y,
         hp,
         maxHp,
         mp,
         maxMp,
         xp,
         level
       };
     }
   );
 }
 
 // Expose helper so the character creation flow can connect when "Start" succeeds
 window.hosgConnectMultiplayerIfNeeded = hosgConnectMultiplayerIfNeeded;
 
       engine.runRenderLoop(function () {
+        if (scene.zoneManager && scene.heroBody) {
+          scene.zoneManager.tick(scene.heroBody.position);
+        }
         scene.render();
       });
 
       window.addEventListener("resize", function () {
         engine.resize();
       });
     })();
   </script>
 </body>
 </html>
\ No newline at end of file
